<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Charts Hub - Single Chart Analysis</title>
    
    <!-- LightweightCharts Library for Interactive Charts -->
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        // Check if library loaded successfully and provide fallback
        window.addEventListener('load', function() {
            if (typeof LightweightCharts === 'undefined') {
                console.error('Primary LightweightCharts library failed to load, trying fallback...');
                
                // Try fallback CDN
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js';
                fallbackScript.onload = function() {
                    if (typeof LightweightCharts !== 'undefined') {
                        console.log('Fallback LightweightCharts library loaded successfully');
                        console.log('Library version:', LightweightCharts.version);
                        console.log('Available methods:', Object.getOwnPropertyNames(LightweightCharts));
                    } else {
                        console.error('Both primary and fallback libraries failed to load');
                        console.warn('Interactive charts will not be available. Please check your internet connection.');
                    }
                };
                fallbackScript.onerror = function() {
                    console.error('Fallback library also failed to load');
                };
                document.head.appendChild(fallbackScript);
            } else {
                console.log('Primary LightweightCharts library loaded successfully');
                console.log('Library version:', LightweightCharts.version);
                console.log('Available methods:', Object.getOwnPropertyNames(LightweightCharts));
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .header-top {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
        }

        .back-btn {
            position: absolute;
            left: 0;
            padding: 10px 20px;
            background: linear-gradient(45deg, #00ccff, #0099cc);
            border: none;
            border-radius: 25px;
            color: #ffffff;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 204, 255, 0.3);
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 204, 255, 0.4);
            background: linear-gradient(45deg, #0099cc, #00ccff);
        }

        .chart-icon {
            display: inline-block;
            width: 28px;
            height: 28px;
            margin-right: 10px;
            position: relative;
            vertical-align: middle;
            background: linear-gradient(135deg, #e0e0e0, #f5f5f5);
            border-radius: 5px;
            border: 2px solid #d0d0d0;
        }

        .chart-icon::before {
            content: '';
            position: absolute;
            bottom: 3px;
            left: 3px;
            right: 3px;
            height: 18px;
            background: 
                linear-gradient(to top, #4CAF50 0%, #4CAF50 40%, transparent 40%),
                linear-gradient(to top, #2196F3 0%, #2196F3 70%, transparent 70%) 5px 0,
                linear-gradient(to top, #FF5722 0%, #FF5722 55%, transparent 55%) 10px 0,
                linear-gradient(to top, #9C27B0 0%, #9C27B0 85%, transparent 85%) 15px 0;
            background-size: 4px 100%;
            background-repeat: no-repeat;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff8800);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 1rem;
            color: #cccccc;
            opacity: 0.9;
        }

        .controls-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            font-weight: 600;
            color: #00ff88;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group select,
        .control-group input {
            padding: 8px 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            background: rgba(255, 255, 255, 0.15);
        }

        .control-group select option {
            background: #1a1a2e;
            color: #ffffff;
            padding: 10px;
        }
        
        .form-text {
            margin-top: 5px;
            font-size: 0.85rem;
            opacity: 0.8;
            transition: all 0.3s ease;
            display: block;
        }
        
        .form-text:hover {
            opacity: 1;
        }
        
        .timeframe-display {
            margin-top: 8px;
            text-align: center;
        }
        
        .timeframe-badge {
            display: inline-block;
            padding: 6px 12px;
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #1a1a2e;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        .generate-btn {
            grid-column: 1 / -1;
            padding: 12px 25px;
            background: linear-gradient(45deg, #00ff88, #00cc66);
            border: none;
            border-radius: 10px;
            color: #1a1a2e;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.3);
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 255, 136, 0.4);
            background: linear-gradient(45deg, #00cc66, #00ff88);
        }

        .generate-btn:active {
            transform: translateY(0);
        }

        .chart-section {
            margin-top: 40px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 400px;
        }

        .chart-container {
            text-align: center;
            margin-top: 20px;
        }

        .indicator-toggle-bar {
            margin-top: 15px;
            display: none;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .indicator-toggle-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .indicator-toggle-bar label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: #cccccc;
            cursor: pointer;
        }

        .indicator-toggle-bar input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .indicator-settings-buttons {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .indicator-settings-button {
            padding: 4px 10px;
            font-size: 0.8rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.4);
            color: #cccccc;
            cursor: pointer;
        }

        .indicator-settings-button:hover {
            background: rgba(0, 255, 136, 0.15);
            color: #00ff88;
        }

        .indicator-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .indicator-modal-content {
            background: #1e1e2f;
            border-radius: 10px;
            padding: 20px 22px;
            width: 320px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .indicator-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .indicator-modal-header h3 {
            margin: 0;
            font-size: 1rem;
            color: #ffffff;
        }

        .indicator-modal-close {
            background: none;
            border: none;
            color: #cccccc;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .indicator-modal-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 10px;
        }

        .indicator-modal-row label {
            font-size: 0.8rem;
            color: #cccccc;
            margin-bottom: 4px;
        }

        .indicator-modal-row input,
        .indicator-modal-row select {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #12121e;
            color: #ffffff;
            font-size: 0.85rem;
        }

        .indicator-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 14px;
        }

        .indicator-btn-secondary,
        .indicator-btn-primary {
            padding: 6px 12px;
            font-size: 0.8rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
        }

        .indicator-btn-secondary {
            background: #333344;
            color: #cccccc;
        }

        .indicator-btn-primary {
            background: #007bff;
            color: #ffffff;
        }

        .chart-image {
            max-width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .chart-info {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-info h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .info-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-item .label {
            font-size: 0.9rem;
            color: #cccccc;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .info-item .value {
            font-size: 1.2rem;
            font-weight: 700;
            color: #00ff88;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #00ff88;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            display: none;
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            color: #ff4444;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
        }

        .data-type-indicator {
            display: inline-block;
            padding: 8px 16px;
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #1a1a2e;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 15px;
        }

        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            color: #cccccc;
            opacity: 0.7;
        }
        
        /* OHLC Tooltip Styles */
        .ohlc-tooltip {
            position: absolute;
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid #00ff88;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #ffffff;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.1s ease;
            transform-origin: center;
            max-width: 200px;
            /* Position relative to chart container */
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .ohlc-tooltip:hover {
            transform: scale(1.02);
        }
        
        .tooltip-header {
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 8px;
            text-align: center;
            border-bottom: 1px solid #00ff88;
            padding-bottom: 4px;
        }
        
        .tooltip-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }
        
        .tooltip-label {
            color: #cccccc;
            min-width: 40px;
        }
        
        .tooltip-value {
            color: #ffffff;
            font-weight: bold;
        }
        
        /* Interactive Chart Container */
        #interactiveChartContainer {
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            position: relative; /* Added for tooltip positioning */
        }
        
        /* Interactive Chart Button */
        .interactive-btn {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        
        .interactive-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
        }

        .timeframe-display {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(0, 204, 255, 0.1);
            border: 1px solid rgba(0, 204, 255, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        .timeframe-badge {
            color: #00ccff;
            font-weight: 600;
        }

        /* Date Selector Styles */
        .date-selector-container {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
        }

        .date-info-section {
            margin: 15px 0 20px 0;
        }

        .date-range-info {
            display: block;
            text-align: left;
            padding: 10px 15px;
            background: rgba(0, 255, 136, 0.15);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 8px;
            color: #00ff88;
            font-weight: 500;
            font-size: 0.9rem;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.2);
            backdrop-filter: blur(10px);
            width: 100%;
            box-sizing: border-box;
        }

        .date-range-info small {
            line-height: 1.4;
            font-size: 0.9rem;
        }

        .weekend-message {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .date-inputs select option:disabled {
            color: #666;
            font-style: italic;
            background-color: rgba(255, 255, 255, 0.05);
        }

        .date-inputs {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            justify-content: space-between;
        }

        .date-inputs select {
            flex: 1;
            max-width: 32%;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .date-inputs select:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .date-inputs select:focus {
            outline: none;
            border-color: #00ccff;
            box-shadow: 0 0 0 2px rgba(0, 204, 255, 0.3);
        }

        .date-navigation {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .nav-btn {
            padding: 6px 12px;
            background: linear-gradient(45deg, #00ccff, #0099cc);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 50px;
        }

        .nav-btn:hover {
            background: linear-gradient(45deg, #0099cc, #00ccff);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 204, 255, 0.3);
        }

        .nav-btn:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .date-inputs {
                flex-direction: column;
                gap: 8px;
            }
            
            .date-navigation {
                flex-direction: row;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-top">
                <button class="back-btn" onclick="goBack()">‚Üê Back to Main</button>
                <h1><span class="chart-icon"></span> Single Chart Analysis</h1>
            </div>
            <p>Detailed analysis of individual instruments with multiple timeframes and chart types</p>
            <div class="data-type-indicator" id="currentDataType">
                {% if selected_data_type == 'nifty_cash' or selected_data_type == 'banknifty_cash' %}Spot
                {% elif selected_data_type == 'nifty_future' or selected_data_type == 'banknifty_future' %}Future
                {% elif selected_data_type == 'nifty_call' or selected_data_type == 'banknifty_call' %}Call
                {% elif selected_data_type == 'nifty_put' or selected_data_type == 'banknifty_put' %}Put
                {% else %}{{ selected_data_type.replace('_', ' ').title() }}
                {% endif %}
            </div>
        </div>

        <!-- Date Range Information Section -->
        <div class="date-info-section">
            <div class="date-range-info" id="dateRangeInfo">
                <small>Loading date range...</small>
            </div>
        </div>

        <div class="controls-section">
            <div class="control-group">
                <label for="symbolSelect">Symbol</label>
                <select id="symbolSelect" onchange="onSymbolChange()">
                    <option value="">Choose a symbol...</option>
                    <option value="nifty" {% if selected_symbol == 'nifty' %}selected{% endif %}>Nifty</option>
                    <option value="banknifty" {% if selected_symbol == 'banknifty' %}selected{% endif %}>Bank Nifty</option>
                    <option value="midcpnifty" {% if selected_symbol == 'midcpnifty' %}selected{% endif %}>Midcap Nifty</option>
                    <option value="sensex" {% if selected_symbol == 'sensex' %}selected{% endif %}>Sensex</option>
                </select>
            </div>

            <div class="control-group">
                <label for="dataType">Data Type</label>
                <select id="dataType" onchange="changeDataType(this.value)">
                    {% for data_type in data_types %}
                        {% if data_type == 'nifty_cash' or data_type == 'banknifty_cash' or data_type == 'midcpnifty_cash' or data_type == 'sensex_cash' %}
                            <option value="{{ data_type }}" {% if selected_data_type == data_type %}selected{% endif %}>Spot</option>
                        {% elif data_type == 'nifty_future' or data_type == 'banknifty_future' or data_type == 'midcpnifty_future' or data_type == 'sensex_future' %}
                            <option value="{{ data_type }}" {% if selected_data_type == data_type %}selected{% endif %}>Future</option>
                        {% elif data_type == 'nifty_call' or data_type == 'banknifty_call' or data_type == 'midcpnifty_call' or data_type == 'sensex_call' %}
                            <option value="{{ data_type }}" {% if selected_data_type == data_type %}selected{% endif %}>Call</option>
                        {% elif data_type == 'nifty_put' or data_type == 'banknifty_put' or data_type == 'midcpnifty_put' or data_type == 'sensex_put' %}
                            <option value="{{ data_type }}" {% if selected_data_type == data_type %}selected{% endif %}>Put</option>
                        {% endif %}
                    {% endfor %}
                </select>
            </div>

            <div class="control-group">
                <label for="dateSelect">Select Date</label>
                <div class="date-selector-container">
                    <div class="date-inputs">
                        <select id="yearSelect" onchange="updateDateOptions(); updateDebugDisplay();">
                            <option value="">Year</option>
                        </select>
                        <select id="monthSelect" onchange="onMonthChange()">
                            <option value="">Month</option>
                        </select>
                        <select id="daySelect" onchange="onDateChange(); updateDebugDisplay();">
                            <option value="">Day</option>
                        </select>
                    </div>
                    <div class="date-navigation">
                        <button type="button" class="nav-btn" onclick="navigateDate(-1)" title="Previous Date">‚óÄ</button>
                        <button type="button" class="nav-btn" onclick="navigateDate(1)" title="Next Date">‚ñ∂</button>
                    </div>
                    <div class="date-debug" id="dateDebug" style="margin-top: 10px; text-align: center; font-size: 12px; color: #00ccff;">
                        <small>Debug: Year: <span id="debugYear">-</span> | Month: <span id="debugMonth">-</span> | Day: <span id="debugDay">-</span></small>
                    </div>
                </div>
            </div>

            <!-- Strike Price dropdown (only for options) -->
            <div class="control-group" id="strikeGroup" style="display: none;">
                <label for="strikeSelect">Strike Price</label>
                <select id="strikeSelect" onchange="onStrikeChange()">
                    <option value="">Choose strike price...</option>
                </select>
            </div>

            <!-- Expiry Date dropdown (only for options) -->
            <div class="control-group" id="expiryGroup" style="display: none;">
                <label for="expirySelect">Expiry Date</label>
                <select id="expirySelect">
                    <option value="">Choose expiry date...</option>
                </select>
            </div>

            <div class="control-group">
                <label for="chartType">Chart Type</label>
                <select id="chartType">
                    <option value="candlestick">Candlestick Chart</option>
                    <option value="summary">Summary Chart</option>
                </select>
            </div>

                          <div class="control-group">
                  <label for="timeframe">Timeframe (minutes)</label>
                  <input type="number" id="timeframe" value="1" min="1" max="60" step="1" onchange="updateTimeframeDisplay()">
                  <small class="form-text" id="timeframeInfo">Select time interval for candlestick formation</small>
                  <div class="timeframe-display" id="timeframeDisplay" style="display: none;">
                      <span class="timeframe-badge">Selected: <strong id="selectedTimeframe">1</strong> min</span>
                  </div>
              </div>

            <button class="generate-btn" onclick="generateChart()">
                Generate Chart
            </button>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p>Generating chart... Please wait.</p>
        </div>

        <div class="error-message" id="errorMessage"></div>
        
        <!-- Interactive Chart Error Message -->
        <div class="error-message" id="interactiveChartError" style="display: none;">
            <p><strong>Interactive chart failed to load:</strong> This could be due to:</p>
            <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
                <li>Internet connection issues</li>
                <li>Chart library not loading properly</li>
                <li>Browser compatibility issues</li>
            </ul>
            <p>The static chart is still available for analysis.</p>
            <button onclick="retryInteractiveChart()" class="generate-btn" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9rem;">
                üîÑ Retry Interactive Chart
            </button>
        </div>

        <div class="chart-section" id="chartSection" style="display: none;">
            <div class="chart-container">
                <img id="chartImage" class="chart-image" alt="Generated Chart">
                
                <!-- Interactive Chart Container -->
                <div id="interactiveChartContainer" style="display: none;">
                    <div id="candlestickChart" style="width: 100%; height: 500px;"></div>
                    
                    <!-- OHLC Tooltip for Interactive Chart -->
                    <div id="ohlcTooltip" class="ohlc-tooltip" style="display: none;">
                        <div class="tooltip-header">OHLC Data</div>
                        <div class="tooltip-content">
                            <div class="tooltip-row">
                                <span class="tooltip-label">Time:</span>
                                <span id="tooltipTime" class="tooltip-value">--</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Open:</span>
                                <span id="tooltipOpen" class="tooltip-value">--</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">High:</span>
                                <span id="tooltipHigh" class="tooltip-value">--</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Low:</span>
                                <span id="tooltipLow" class="tooltip-value">--</span>
                            </div>
                            <div class="tooltip-row">
                                <span class="tooltip-label">Close:</span>
                                <span id="tooltipClose" class="tooltip-value">--</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="indicator-toggle-bar" id="indicatorToggleBar">
                    <span class="indicator-toggle-title">Indicators</span>
                    <label>
                        <input type="checkbox" id="toggleEMA20" checked>
                        EMA 20
                    </label>
                    <label>
                        <input type="checkbox" id="toggleSMA" checked>
                        SMA
                    </label>
                    <label>
                        <input type="checkbox" id="toggleVWAP" checked>
                        VWAP
                    </label>
                    <label>
                        <input type="checkbox" id="toggleMACD" checked>
                        MACD
                    </label>
                    <label>
                        <input type="checkbox" id="toggleRSI" checked>
                        RSI
                    </label>
                    <label>
                        <input type="checkbox" id="toggleSupertrend" checked>
                        Supertrend
                    </label>
                </div>
                <div class="indicator-settings-buttons">
                    <button type="button" class="indicator-settings-button" onclick="openEMAModal()">EMA Settings</button>
                    <button type="button" class="indicator-settings-button" onclick="openSMAModal()">SMA Settings</button>
                    <button type="button" class="indicator-settings-button" onclick="openRSIModal()">RSI Settings</button>
                    <button type="button" class="indicator-settings-button" onclick="openSupertrendModal()">Supertrend Settings</button>
                </div>
            </div>
            
            <div class="chart-info">
                <h3 id="chartTitle">Chart Information</h3>
                <div class="info-grid" id="chartInfo">
                    <!-- Chart information will be populated here -->
                </div>
            </div>
        </div>

        <div class="indicator-modal" id="emaSettingsModal">
            <div class="indicator-modal-content">
                <div class="indicator-modal-header">
                    <h3>Exponential Moving Average</h3>
                    <button type="button" class="indicator-modal-close" onclick="closeEMAModal()">√ó</button>
                </div>
                <div class="indicator-modal-body">
                    <div class="indicator-modal-row">
                        <label for="emaSource">Source</label>
                        <select id="emaSource">
                            <option value="close">.close</option>
                        </select>
                    </div>
                    <div class="indicator-modal-row">
                        <label for="emaPeriodInput">Periods</label>
                        <input type="number" id="emaPeriodInput" value="20" min="1" step="1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="emaColorInput">Line Color</label>
                        <input type="color" id="emaColorInput" value="#ffcc00">
                    </div>
                </div>
                <div class="indicator-modal-footer">
                    <button type="button" class="indicator-btn-secondary" onclick="closeEMAModal()">Close</button>
                    <button type="button" class="indicator-btn-primary" onclick="applyEMAModal()">Apply</button>
                </div>
            </div>
        </div>

        <div class="indicator-modal" id="smaSettingsModal">
            <div class="indicator-modal-content">
                <div class="indicator-modal-header">
                    <h3>Simple Moving Averages</h3>
                    <button type="button" class="indicator-modal-close" onclick="closeSMAModal()">√ó</button>
                </div>
                <div class="indicator-modal-body">
                    <div class="indicator-modal-row">
                        <label for="smaSource">Source</label>
                        <select id="smaSource">
                            <option value="close">.close</option>
                        </select>
                    </div>
                    <div class="indicator-modal-row">
                        <label for="sma1PeriodInput">SMA 1 Period</label>
                        <input type="number" id="sma1PeriodInput" value="20" min="1" step="1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="sma1ColorInput">SMA 1 Color</label>
                        <input type="color" id="sma1ColorInput" value="#ff0000">
                    </div>
                    <div class="indicator-modal-row">
                        <label>
                            <input type="checkbox" id="sma1Enabled" checked>
                            Enable SMA 1
                        </label>
                    </div>
                    <div class="indicator-modal-row">
                        <label for="sma2PeriodInput">SMA 2 Period</label>
                        <input type="number" id="sma2PeriodInput" value="50" min="1" step="1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="sma2ColorInput">SMA 2 Color</label>
                        <input type="color" id="sma2ColorInput" value="#00ccff">
                    </div>
                    <div class="indicator-modal-row">
                        <label>
                            <input type="checkbox" id="sma2Enabled">
                            Enable SMA 2
                        </label>
                    </div>
                    <div class="indicator-modal-row">
                        <label for="sma3PeriodInput">SMA 3 Period</label>
                        <input type="number" id="sma3PeriodInput" value="200" min="1" step="1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="sma3ColorInput">SMA 3 Color</label>
                        <input type="color" id="sma3ColorInput" value="#ffffff">
                    </div>
                    <div class="indicator-modal-row">
                        <label>
                            <input type="checkbox" id="sma3Enabled">
                            Enable SMA 3
                        </label>
                    </div>
                </div>
                <div class="indicator-modal-footer">
                    <button type="button" class="indicator-btn-secondary" onclick="closeSMAModal()">Close</button>
                    <button type="button" class="indicator-btn-primary" onclick="applySMAModal()">Apply</button>
                </div>
            </div>
        </div>

        <div class="indicator-modal" id="rsiSettingsModal">
            <div class="indicator-modal-content">
                <div class="indicator-modal-header">
                    <h3>Relative Strength Index</h3>
                    <button type="button" class="indicator-modal-close" onclick="closeRSIModal()">√ó</button>
                </div>
                <div class="indicator-modal-body">
                    <div class="indicator-modal-row">
                        <label for="rsiSource">Source</label>
                        <select id="rsiSource">
                            <option value="close">.close</option>
                        </select>
                    </div>
                    <div class="indicator-modal-row">
                        <label for="rsiPeriodInput">Periods</label>
                        <input type="number" id="rsiPeriodInput" value="14" min="1" step="1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="rsiColorInput">Line Color</label>
                        <input type="color" id="rsiColorInput" value="#ffaa00">
                    </div>
                </div>
                <div class="indicator-modal-footer">
                    <button type="button" class="indicator-btn-secondary" onclick="closeRSIModal()">Close</button>
                    <button type="button" class="indicator-btn-primary" onclick="applyRSIModal()">Apply</button>
                </div>
            </div>
        </div>

        <div class="indicator-modal" id="supertrendSettingsModal">
            <div class="indicator-modal-content">
                <div class="indicator-modal-header">
                    <h3>Supertrend</h3>
                    <button type="button" class="indicator-modal-close" onclick="closeSupertrendModal()">√ó</button>
                </div>
                <div class="indicator-modal-body">
                    <div class="indicator-modal-row">
                        <label for="supertrendSource">Source</label>
                        <select id="supertrendSource">
                            <option value="close">.close</option>
                        </select>
                    </div>
                    <div class="indicator-modal-row">
                        <label for="supertrendPeriodInput">ATR Period</label>
                        <input type="number" id="supertrendPeriodInput" value="10" min="1" step="1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="supertrendMultiplierInput">Multiplier</label>
                        <input type="number" id="supertrendMultiplierInput" value="3" min="0.1" step="0.1">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="supertrendUpColorInput">Uptrend Color</label>
                        <input type="color" id="supertrendUpColorInput" value="#00ff88">
                    </div>
                    <div class="indicator-modal-row">
                        <label for="supertrendDownColorInput">Downtrend Color</label>
                        <input type="color" id="supertrendDownColorInput" value="#ff4444">
                    </div>
                </div>
                <div class="indicator-modal-footer">
                    <button type="button" class="indicator-btn-secondary" onclick="closeSupertrendModal()">Close</button>
                    <button type="button" class="indicator-btn-primary" onclick="applySupertrendModal()">Apply</button>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>&copy; 2024 Trading Charts Hub. All rights reserved.</p>
        </div>
    </div>

    <script>
        function changeDataType(dataType) {
            // Update the current data type indicator with user-friendly names
            const displayNames = {
                'nifty_cash': 'Spot',
                'nifty_future': 'Future',
                'nifty_call': 'Call',
                'nifty_put': 'Put',
                'banknifty_cash': 'Spot',
                'banknifty_future': 'Future',
                'banknifty_call': 'Call',
                'banknifty_put': 'Put',
                'midcpnifty_cash': 'Spot',
                'midcpnifty_future': 'Future',
                'midcpnifty_call': 'Call',
                'midcpnifty_put': 'Put',
                'sensex_cash': 'Spot',
                'sensex_future': 'Future',
                'sensex_call': 'Call',
                'sensex_put': 'Put'
            };
            document.getElementById('currentDataType').textContent = displayNames[dataType] || dataType.replace('_', ' ').title();
            
            // Immediately clear date dropdowns to prevent showing old dates
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const daySelect = document.getElementById('daySelect');
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            
            if (yearSelect) yearSelect.innerHTML = '<option value="">Year</option>';
            if (monthSelect) monthSelect.innerHTML = '<option value="">Month</option>';
            if (daySelect) daySelect.innerHTML = '<option value="">Day</option>';
            if (dateRangeInfo) {
                dateRangeInfo.innerHTML = '<small style="color: #00ccff;">üîÑ Loading date range for ' + (displayNames[dataType] || dataType) + '...</small>';
            }
            
            // Clear debug display
            const debugDisplay = document.getElementById('dateDebug');
            if (debugDisplay) {
                debugDisplay.innerHTML = '<small>Debug: Year: <span id="debugYear">-</span> | Month: <span id="debugMonth">-</span> | Day: <span id="debugDay">-</span></small>';
            }
            
            console.log('Date dropdowns cleared immediately on data type change');
            
            // Clear previous chart
            document.getElementById('chartSection').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'none';
            
            // Clear interactive chart button
            const existingBtn = document.getElementById('interactiveChartBtn');
            if (existingBtn) {
                existingBtn.remove();
            }
            
            // Show/hide strike and expiry dropdowns based on data type
            const strikeGroup = document.getElementById('strikeGroup');
            const expiryGroup = document.getElementById('expiryGroup');
            
            if (dataType === 'nifty_call' || dataType === 'nifty_put' || 
                dataType === 'banknifty_call' || dataType === 'banknifty_put' ||
                dataType === 'midcpnifty_call' || dataType === 'midcpnifty_put' ||
                dataType === 'sensex_call' || dataType === 'sensex_put') {
                strikeGroup.style.display = 'flex';
                expiryGroup.style.display = 'flex';
            } else {
                strikeGroup.style.display = 'none';
                expiryGroup.style.display = 'none';
            }
            
            // Clear strike and expiry selections
            document.getElementById('strikeSelect').innerHTML = '<option value="">Choose strike price...</option>';
            document.getElementById('expirySelect').innerHTML = '<option value="">Choose expiry date...</option>';
            
            // Get dates for the new data type
            // Determine symbol from data type
            let symbol = 'nifty';
            if (dataType.startsWith('banknifty_')) {
                symbol = 'banknifty';
            } else if (dataType.startsWith('midcpnifty_')) {
                symbol = 'midcpnifty';
            } else if (dataType.startsWith('sensex_')) {
                symbol = 'sensex';
            }
            
            // Fetch date range and populate date selectors
            fetch(`/get_date_range?data_type=${dataType}&symbol=${symbol}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Date range API response:', data);
                    if (data.date_range) {
                        populateDateSelectors(data.date_range);
                    } else if (data.error) {
                        console.error('API error:', data.error);
                        const dateRangeInfo = document.getElementById('dateRangeInfo');
                        dateRangeInfo.innerHTML = `
                            <strong>Error:</strong> ${data.error}<br>
                            <small style="color: #ff4444;">
                                Please try refreshing the page or contact support.
                            </small>
                        `;
                    } else {
                        console.error('No date range data received');
                        const dateRangeInfo = document.getElementById('dateRangeInfo');
                        dateRangeInfo.innerHTML = `
                            <strong>Error:</strong> No date range data received<br>
                            <small style="color: #ff4444;">
                                Please try refreshing the page or contact support.
                            </small>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error fetching date range:', error);
                    const dateRangeInfo = document.getElementById('dateRangeInfo');
                    dateRangeInfo.innerHTML = `
                        <strong>Error:</strong> Failed to fetch date range<br>
                        <small style="color: #ff4444;">
                            Network error: ${error.message}<br>
                            Please check your connection and try again.
                        </small>
                    `;
                });
        }

        function onSymbolChange() {
            const symbol = document.getElementById('symbolSelect').value;
            if (!symbol) return;
            
            // Update the data type dropdown based on selected symbol
            updateDataTypesForSymbol(symbol);
            
            // Update date range for the new symbol
            updateDateRange();
        }

        function updateDataTypesForSymbol(symbol) {
            const dataTypeSelect = document.getElementById('dataType');
            const currentValue = dataTypeSelect.value;
            
            // Clear existing options
            dataTypeSelect.innerHTML = '';
            
            // Define data types for each symbol
            const symbolDataTypes = {
                'nifty': [
                    { value: 'nifty_cash', label: 'Spot' },
                    { value: 'nifty_future', label: 'Future' },
                    { value: 'nifty_call', label: 'Call' },
                    { value: 'nifty_put', label: 'Put' }
                ],
                'banknifty': [
                    { value: 'banknifty_cash', label: 'Spot' },
                    { value: 'banknifty_future', label: 'Future' },
                    { value: 'banknifty_call', label: 'Call' },
                    { value: 'banknifty_put', label: 'Put' }
                ],
                'midcpnifty': [
                    { value: 'midcpnifty_cash', label: 'Spot' },
                    { value: 'midcpnifty_future', label: 'Future' },
                    { value: 'midcpnifty_call', label: 'Call' },
                    { value: 'midcpnifty_put', label: 'Put' }
                ],
                'sensex': [
                    { value: 'sensex_cash', label: 'Spot' },
                    { value: 'sensex_future', label: 'Future' },
                    { value: 'sensex_call', label: 'Call' },
                    { value: 'sensex_put', label: 'Put' }
                ]
            };
            
            const dataTypes = symbolDataTypes[symbol] || [];
            
            // Add options
            dataTypes.forEach(dataType => {
                const option = document.createElement('option');
                option.value = dataType.value;
                option.textContent = dataType.label;
                dataTypeSelect.appendChild(option);
            });
            
            // Select the first option (usually Spot)
            if (dataTypes.length > 0) {
                dataTypeSelect.value = dataTypes[0].value;
                changeDataType(dataTypes[0].value);
            }
        }

        function updateDateRange() {
            const symbol = document.getElementById('symbolSelect').value;
            const dataType = document.getElementById('dataType').value;
            
            if (!symbol || !dataType) return;
            
            // Fetch date range and populate date selectors
            fetch(`/get_date_range?data_type=${dataType}&symbol=${symbol}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Date range API response:', data);
                    if (data.date_range) {
                        populateDateSelectors(data.date_range);
                    } else if (data.error) {
                        console.error('API error:', data.error);
                        const dateRangeInfo = document.getElementById('dateRangeInfo');
                        dateRangeInfo.innerHTML = `
                            <strong>Error:</strong> ${data.error}<br>
                            <small style="color: #ff4444;">
                                Please try refreshing the page or contact support.
                            </small>
                        `;
                    } else {
                        console.error('No date range data received');
                        const dateRangeInfo = document.getElementById('dateRangeInfo');
                        dateRangeInfo.innerHTML = `
                            <strong>Error:</strong> No date range data received<br>
                            <small style="color: #ff4444;">
                                Please try refreshing the page or contact support.
                            </small>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error fetching date range:', error);
                    const dateRangeInfo = document.getElementById('dateRangeInfo');
                    dateRangeInfo.innerHTML = `
                        <strong>Error:</strong> Failed to fetch date range<br>
                        <small style="color: #ff4444;">
                            Network error: ${error.message}<br>
                            Please check your connection and try again.
                        </small>
                    `;
                });
        }
        
        function updateTimeframeDisplay() {
            const timeframe = document.getElementById('timeframe').value;
            const timeframeInfo = document.getElementById('timeframeInfo');
            const timeframeDisplay = document.getElementById('timeframeDisplay');
            const selectedTimeframe = document.getElementById('selectedTimeframe');
            
            // Update the info text based on selection
            if (timeframe === '1') {
                timeframeInfo.textContent = 'Real-time 1-minute candlesticks for detailed analysis';
                timeframeInfo.style.color = '#00ff88';
            } else if (timeframe <= '5') {
                timeframeInfo.textContent = `${timeframe}-minute candlesticks for short-term trading`;
                timeframeInfo.style.color = '#00ccff';
            } else if (timeframe <= '10') {
                timeframeInfo.textContent = `${timeframe}-minute candlesticks for medium-term analysis`;
                timeframeInfo.style.color = '#ff8800';
            } else {
                timeframeInfo.textContent = `${timeframe}-minute candlesticks for swing trading`;
                timeframeInfo.style.color = '#ff4444';
            }
            
            // Update the timeframe display
            selectedTimeframe.textContent = timeframe;
            timeframeDisplay.style.display = 'block';
        }

        // Global variables for date navigation
        let availableDates = [];
        let currentDateIndex = 0;

        function calculateActualWeekends(startDateStr, endDateStr) {
            /**
             * Calculate actual weekend days between two dates
             * @param {string} startDateStr - Start date in YYYY-MM-DD format
             * @param {string} endDateStr - End date in YYYY-MM-DD format
             * @returns {number} Number of actual weekend days
             */
            try {
                const startDate = new Date(startDateStr);
                const endDate = new Date(endDateStr);
                let weekendCount = 0;
                let currentDate = new Date(startDate);
                
                while (currentDate <= endDate) {
                    // Saturday = 6, Sunday = 0
                    if (currentDate.getDay() === 0 || currentDate.getDay() === 6) {
                        weekendCount++;
                    }
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                
                return weekendCount;
            } catch (error) {
                console.error('Error calculating actual weekends:', error);
                return 0;
            }
        }

        function showWeekendMessage(weekendDate, tradingDate) {
            const weekendStr = weekendDate.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            const tradingStr = new Date(tradingDate).toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            // Create a temporary message
            const messageDiv = document.createElement('div');
            messageDiv.className = 'weekend-message';
            messageDiv.innerHTML = `
                <div style="background: rgba(255, 165, 0, 0.1); border: 1px solid rgba(255, 165, 0, 0.3); border-radius: 8px; padding: 10px; margin: 10px 0; color: #ffa500; text-align: center;">
                    <strong>Weekend Skipped:</strong> ${weekendStr} (No trading data)<br>
                    <strong>Navigated to:</strong> ${tradingStr} (Trading day)
                </div>
            `;
            
            // Insert after the date range info
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            dateRangeInfo.parentNode.insertBefore(messageDiv, dateRangeInfo.nextSibling);
            
            // Remove the message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        function populateDateSelectors(dateRange) {
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const daySelect = document.getElementById('daySelect');
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            
            // Clear existing options
            yearSelect.innerHTML = '<option value="">Year</option>';
            monthSelect.innerHTML = '<option value="">Month</option>';
            daySelect.innerHTML = '<option value="">Day</option>';
            
            // Debug: Log the date range data
            console.log('Date range data received:', dateRange);
            console.log('Min date string:', dateRange.min_date);
            console.log('Max date string:', dateRange.max_date);
            
            // Parse min and max dates first with validation
            const minDate = new Date(dateRange.min_date);
            const maxDate = new Date(dateRange.max_date);
            
            // Debug: Log parsed dates
            console.log('Parsed min date:', minDate);
            console.log('Parsed max date:', maxDate);
            console.log('Min date valid:', !isNaN(minDate.getTime()));
            console.log('Max date valid:', !isNaN(maxDate.getTime()));
            
            // Validate dates
            if (isNaN(minDate.getTime()) || isNaN(maxDate.getTime())) {
                console.error('Invalid date range:', {
                    min_date: dateRange.min_date,
                    max_date: dateRange.max_date,
                    minDate: minDate,
                    maxDate: maxDate
                });
                
                // Show error in UI
                dateRangeInfo.innerHTML = `
                    <strong>Error:</strong> Invalid date range data<br>
                    <small style="color: #ff4444;">
                        Min: ${dateRange.min_date || 'undefined'} | Max: ${dateRange.max_date || 'undefined'}<br>
                        Please refresh the page or contact support.
                    </small>
                `;
                return;
            }
            
            // Don't populate years initially - will be populated from actual database dates
            yearSelect.innerHTML = '<option value="">Year</option>';
            
            // Fetch actual available dates from database to show real trading days
            const dataTypeSelect = document.getElementById('dataType');
            const currentDataType = dataTypeSelect ? dataTypeSelect.value : 'nifty_cash';
            let currentSymbol = 'nifty';
            if (currentDataType.startsWith('banknifty_')) {
                currentSymbol = 'banknifty';
            } else if (currentDataType.startsWith('midcpnifty_')) {
                currentSymbol = 'midcpnifty';
            } else if (currentDataType.startsWith('sensex_')) {
                currentSymbol = 'sensex';
            }
            
            console.log('Fetching dates for:', { currentDataType, currentSymbol });
            
            fetch(`/get_dates?data_type=${currentDataType}&symbol=${currentSymbol}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Received data:', data);
                    if (data.dates && data.dates.length > 0) {
                        availableDates = data.dates;
                        
                        // Calculate actual trading days and weekend info from database data
                        // Use the ACTUAL first and last dates from availableDates, not the API date range
                        const actualMinDate = availableDates[0];  // First date from database
                        const actualMaxDate = availableDates[availableDates.length - 1];  // Last date from database
                        
                        const minDateObj = new Date(actualMinDate);
                        const maxDateObj = new Date(actualMaxDate);
                        const totalCalendarDays = Math.ceil((maxDateObj - minDateObj) / (1000 * 60 * 60 * 24)) + 1;
                        const actualTradingDays = availableDates.length;
                        const actualWeekends = calculateActualWeekends(actualMinDate, actualMaxDate);
                        const holidays = totalCalendarDays - actualTradingDays - actualWeekends;
                        
                        // Debug logging for negative holidays issue
                        console.log('Date Range Debug:', {
                            dataType: currentDataType,
                            apiDateRange: dateRange.min_date + ' to ' + dateRange.max_date,
                            actualDateRange: actualMinDate + ' to ' + actualMaxDate,
                            totalCalendarDays,
                            actualTradingDays,
                            actualWeekends,
                            holidays,
                            isNegativeHolidays: holidays < 0,
                            availableDatesCount: availableDates.length,
                            expectedTradingDays: totalCalendarDays - actualWeekends,
                            excessTradingDays: actualTradingDays - (totalCalendarDays - actualWeekends)
                        });
                        
                        // Debug: Check for calculation issues with options data
                        if (holidays < 0) {
                            console.error('CALCULATION ERROR: Negative holidays detected!', {
                                dataType: currentDataType,
                                totalCalendarDays,
                                actualTradingDays,
                                actualWeekends,
                                calculatedHolidays: holidays,
                                dateRange: `${dateRange.min_date} to ${dateRange.max_date}`,
                                availableDatesFirst10: availableDates.slice(0, 10),
                                availableDatesLast10: availableDates.slice(-10)
                            });
                            
                            // For options data with calculation errors, show a warning
                            if (currentDataType && (currentDataType.includes('_call') || currentDataType.includes('_put'))) {
                                console.warn('This appears to be options data with more trading days than calendar calculation expects');
                            }
                        }
                        
                        // Update date range info with REAL database data
                        dateRangeInfo.innerHTML = `
                            <strong>Available Date Range:</strong> ${actualMinDate} to ${actualMaxDate} | üìÖ <strong>Total Days:</strong> ${totalCalendarDays} | üìä <strong>Trading Days:</strong> ${actualTradingDays} | üèñÔ∏è <strong>Weekends:</strong> ${actualWeekends} | üèõÔ∏è <strong>Holidays:</strong> ${holidays}
                        `;
                        
                        // Update year dropdown with actual available years from database (same as Options Chain)
                        const yearSelect = document.getElementById('yearSelect');
                        const currentYearValue = yearSelect.value; // Preserve current selection
                        
                        // Get unique years from available dates (same method as Options Chain)
                        const years = [...new Set(availableDates.map(date => date.substring(0, 4)))].sort();
                        
                        // Clear and repopulate with actual years from database
                        yearSelect.innerHTML = '<option value="">Year</option>';
                        years.forEach(year => {
                            const option = document.createElement('option');
                            option.value = year;
                            option.textContent = year;
                            if (year === currentYearValue) {
                                option.selected = true; // Restore selection if still valid
                            }
                            yearSelect.appendChild(option);
                        });
                        
                        console.log(`Year dropdown updated with years: ${years.join(', ')}`);
                        console.log('Date dropdowns ready - please select Year, Month, and Day manually');
                        
                        // Set current date index to middle of range
                        currentDateIndex = Math.floor(availableDates.length / 2);
                        
                        // Enable/disable navigation buttons
                        updateNavigationButtons();
                        
                        // Update debug display
                        updateDebugDisplay();
                        
                        console.log('Database dates loaded:', {
                            totalCalendarDays,
                            actualTradingDays,
                            actualWeekends,
                            holidays,
                            availableDatesCount: availableDates.length
                        });
                    } else {
                        console.warn('No dates received from database, using fallback');
                        fallbackDateCalculation(minDate, maxDate, dateRange);
                    }
                })
                .catch(error => {
                    console.error('Error fetching available dates:', error);
                    console.log('Using fallback calculation due to error');
                    fallbackDateCalculation(minDate, maxDate, dateRange);
                });
        }
        
        function fallbackDateCalculation(minDate, maxDate, dateRange) {
            // Fallback calculation if database fetch fails
            availableDates = [];
            
            // Validate dates before proceeding
            if (isNaN(minDate.getTime()) || isNaN(maxDate.getTime())) {
                console.error('Invalid dates in fallback calculation:', {
                    minDate: minDate,
                    maxDate: maxDate,
                    dateRange: dateRange
                });
                
                const dateRangeInfo = document.getElementById('dateRangeInfo');
                dateRangeInfo.innerHTML = `
                    <strong>Error:</strong> Invalid date range data<br>
                    <small style="color: #ff4444;">
                        Min: ${dateRange.min_date || 'undefined'} | Max: ${dateRange.max_date || 'undefined'}<br>
                        Please refresh the page or contact support.
                    </small>
                `;
                return;
            }
            
            const currentDate = new Date(minDate);
            while (currentDate <= maxDate) {
                const dayOfWeek = currentDate.getDay();
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                
                if (!isWeekend) {
                    availableDates.push(currentDate.toISOString().split('T')[0]);
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            const totalCalendarDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24)) + 1;
            const actualTradingDays = availableDates.length;
            const actualWeekends = calculateActualWeekends(dateRange.min_date, dateRange.max_date);
            const holidays = totalCalendarDays - actualTradingDays - actualWeekends;
            
            // Debug: Check for calculation issues in fallback
            if (holidays < 0) {
                console.error('FALLBACK CALCULATION ERROR: Negative holidays!', {
                    totalCalendarDays,
                    actualTradingDays,
                    actualWeekends,
                    calculatedHolidays: holidays
                });
            }
            
            const dateRangeInfo = document.getElementById('dateRangeInfo');
            dateRangeInfo.innerHTML = `
                <strong>Available Date Range:</strong> ${dateRange.min_date} to ${dateRange.max_date} | üìÖ <strong>Total Days:</strong> ${totalCalendarDays} | üìä <strong>Trading Days:</strong> ${actualTradingDays} | üèñÔ∏è <strong>Weekends:</strong> ${actualWeekends} | üèõÔ∏è <strong>Holidays:</strong> ${holidays}
            `;
            
            currentDateIndex = Math.floor(availableDates.length / 2);
            updateNavigationButtons();
            updateDebugDisplay();
        }

        function updateDateOptions() {
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const daySelect = document.getElementById('daySelect');
            
            const selectedYear = yearSelect.value;
            const selectedMonth = monthSelect.value;
            
            // Only clear month and day selectors if year changed
            if (yearSelect.dataset.lastYear !== selectedYear) {
                monthSelect.innerHTML = '<option value="">Month</option>';
                daySelect.innerHTML = '<option value="">Day</option>';
                
                // Populate month selector
                for (let month = 1; month <= 12; month++) {
                    const option = document.createElement('option');
                    option.value = month.toString().padStart(2, '0');
                    option.textContent = new Date(selectedYear, month - 1, 1).toLocaleDateString('en-US', { month: 'long' });
                    monthSelect.appendChild(option);
                }
                
                // Store the year we just processed
                yearSelect.dataset.lastYear = selectedYear;
            }
            
            // Only populate day selector if month is selected and year hasn't changed
            if (selectedMonth && selectedYear) {
                // Check if day selector is already populated
                if (daySelect.children.length <= 1) {
                    // Filter available days from database for this year-month (same as Options Chain)
                    const yearMonth = `${selectedYear}-${selectedMonth}`;
                    const availableDays = availableDates
                        .filter(date => date.startsWith(yearMonth))
                        .map(date => date.substring(8, 10))
                        .sort((a, b) => parseInt(a) - parseInt(b));
                    
                    // Show all days in month but only enable available ones
                    const daysInMonth = new Date(selectedYear, parseInt(selectedMonth), 0).getDate();
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dayStr = day.toString().padStart(2, '0');
                        const option = document.createElement('option');
                        option.value = dayStr;
                        
                        // Check if this day is available in database
                        const isAvailable = availableDays.includes(dayStr);
                        
                        // Check if this is a weekend
                        const date = new Date(selectedYear, parseInt(selectedMonth) - 1, day);
                        const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
                        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                        
                        if (isWeekend) {
                            option.textContent = `${day} (Weekend)`;
                            option.disabled = true;
                            option.style.color = '#ff8888';
                            option.style.fontStyle = 'italic';
                        } else if (!isAvailable) {
                            option.textContent = `${day} (Holiday)`;
                            option.disabled = true;
                            option.style.color = '#666';
                            option.style.fontStyle = 'italic';
                        } else {
                            option.textContent = day;
                        }
                        
                        daySelect.appendChild(option);
                    }
                }
            }
            
            // Update debug display
            updateDebugDisplay();
        }

        function onMonthChange() {
            const selectedMonth = document.getElementById('monthSelect').value;
            const selectedYear = document.getElementById('yearSelect').value;
            console.log('Month changed:', selectedMonth);
            
            // Only populate day selector if month is selected
            if (selectedMonth && selectedYear) {
                const daySelect = document.getElementById('daySelect');
                daySelect.innerHTML = '<option value="">Day</option>';
                
                // Filter available days from database for this year-month (same as Options Chain)
                const yearMonth = `${selectedYear}-${selectedMonth}`;
                const availableDays = availableDates
                    .filter(date => date.startsWith(yearMonth))
                    .map(date => date.substring(8, 10))
                    .sort((a, b) => parseInt(a) - parseInt(b));
                
                const daysInMonth = new Date(selectedYear, parseInt(selectedMonth), 0).getDate();
                for (let day = 1; day <= daysInMonth; day++) {
                    const dayStr = day.toString().padStart(2, '0');
                    const option = document.createElement('option');
                    option.value = dayStr;
                    
                    // Check if this day is available in database
                    const isAvailable = availableDays.includes(dayStr);
                    
                    // Check if this is a weekend
                    const date = new Date(selectedYear, parseInt(selectedMonth) - 1, day);
                    const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
                    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                    
                    if (isWeekend) {
                        option.textContent = `${day} (Weekend)`;
                        option.disabled = true;
                        option.style.color = '#ff8888';
                        option.style.fontStyle = 'italic';
                    } else if (!isAvailable) {
                        option.textContent = `${day} (Holiday)`;
                        option.disabled = true;
                        option.style.color = '#666';
                        option.style.fontStyle = 'italic';
                    } else {
                        option.textContent = day;
                    }
                    
                    daySelect.appendChild(option);
                }
            }
            
            updateDebugDisplay();
        }

        function updateDebugDisplay() {
            const year = document.getElementById('yearSelect').value || '-';
            const month = document.getElementById('monthSelect').value || '-';
            const day = document.getElementById('daySelect').value || '-';
            
            document.getElementById('debugYear').textContent = year;
            document.getElementById('debugMonth').textContent = month;
            document.getElementById('debugDay').textContent = day;
        }

        function findNextTradingDay(date) {
            let nextDay = new Date(date);
            nextDay.setDate(nextDay.getDate() + 1);
            
            // Keep moving forward until we find a weekday
            while (nextDay.getDay() === 0 || nextDay.getDay() === 6) {
                nextDay.setDate(nextDay.getDate() + 1);
            }
            
            return nextDay;
        }

        function findPreviousTradingDay(date) {
            let prevDay = new Date(date);
            prevDay.setDate(prevDay.getDate() - 1);
            
            // Keep moving backward until we find a weekday
            while (prevDay.getDay() === 0 || prevDay.getDay() === 6) {
                prevDay.setDate(prevDay.getDate() - 1);
            }
            
            return prevDay;
        }

        function isWeekend(date) {
            const dayOfWeek = date.getDay();
            return dayOfWeek === 0 || dayOfWeek === 6;
        }

        function getSelectedDate() {
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const daySelect = document.getElementById('daySelect');
            
            if (!yearSelect || !monthSelect || !daySelect) {
                console.warn('Date selector elements not found');
                return null;
            }
            
            const year = yearSelect.value;
            const month = monthSelect.value;
            const day = daySelect.value;
            
            console.log('getSelectedDate called:', { year, month, day });
            
            if (year && month && day) {
                const selectedDate = `${year}-${month}-${day}`;
                console.log('Selected date:', selectedDate);
                return selectedDate;
            }
            
            console.warn('Incomplete date selection:', { year, month, day });
            return null;
        }

        function navigateDate(direction) {
            if (availableDates.length === 0) return;
            
            let targetDate;
            if (direction > 0) {
                // Next date
                currentDateIndex++;
                if (currentDateIndex >= availableDates.length) {
                    currentDateIndex = availableDates.length - 1;
                    return;
                }
                targetDate = availableDates[currentDateIndex];
            } else {
                // Previous date
                currentDateIndex--;
                if (currentDateIndex < 0) {
                    currentDateIndex = 0;
                    return;
                }
                targetDate = availableDates[currentDateIndex];
            }
            
            // Check if target date is a weekend
            const targetDateObj = new Date(targetDate);
            if (isWeekend(targetDateObj)) {
                // Find the next/previous trading day
                if (direction > 0) {
                    targetDateObj = findNextTradingDay(targetDateObj);
                } else {
                    targetDateObj = findPreviousTradingDay(targetDateObj);
                }
                
                // Update targetDate to the trading day
                targetDate = targetDateObj.toISOString().split('T')[0];
                
                // Find the index of this trading day in availableDates
                const newIndex = availableDates.indexOf(targetDate);
                if (newIndex !== -1) {
                    currentDateIndex = newIndex;
                }
            }
            
            const dateParts = targetDate.split('-');
            
            // Update selectors without triggering updateDateOptions multiple times
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const daySelect = document.getElementById('daySelect');
            
            // Set year first
            yearSelect.value = dateParts[0];
            // Clear the lastYear dataset to force month repopulation
            delete yearSelect.dataset.lastYear;
            updateDateOptions();
            
            // Set month and day
            monthSelect.value = dateParts[1];
            daySelect.value = dateParts[2];
            
            // Trigger date change
            onDateChange();
            
            // Update navigation buttons
            updateNavigationButtons();
            
            // Show feedback if we skipped a weekend
            const originalDate = new Date(availableDates[direction > 0 ? currentDateIndex - 1 : currentDateIndex + 1]);
            if (isWeekend(originalDate)) {
                showWeekendMessage(originalDate, targetDate);
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.querySelector('.nav-btn[onclick="navigateDate(-1)"]');
            const nextBtn = document.querySelector('.nav-btn[onclick="navigateDate(1)"]');
            
            if (prevBtn) prevBtn.disabled = currentDateIndex <= 0;
            if (nextBtn) nextBtn.disabled = currentDateIndex >= availableDates.length - 1;
        }

        function onDateChange() {
            const dataType = document.getElementById('dataType').value;
            const date = getSelectedDate();
            
            if (!date) return;
            
            // If it's an option type, get strikes for the selected date
            if (dataType === 'nifty_call' || dataType === 'nifty_put' || 
                dataType === 'banknifty_call' || dataType === 'banknifty_put' ||
                dataType === 'midcpnifty_call' || dataType === 'midcpnifty_put' ||
                dataType === 'sensex_call' || dataType === 'sensex_put') {
                
                // Determine symbol from data type
                let symbol = 'nifty';
                if (dataType.startsWith('banknifty_')) {
                    symbol = 'banknifty';
                } else if (dataType.startsWith('midcpnifty_')) {
                    symbol = 'midcpnifty';
                } else if (dataType.startsWith('sensex_')) {
                    symbol = 'sensex';
                }
                
                fetch(`/get_strikes?date=${date}&data_type=${dataType}&symbol=${symbol}`)
                    .then(response => response.json())
                    .then(data => {
                        const strikeSelect = document.getElementById('strikeSelect');
                        strikeSelect.innerHTML = '<option value="">Choose strike price...</option>';
                        
                        if (data.strikes && data.strikes.length > 0) {
                            data.strikes.forEach(strike => {
                                const option = document.createElement('option');
                                option.value = strike;
                                option.textContent = strike;
                                strikeSelect.appendChild(option);
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching strikes:', error);
                    });
            }
        }

        function onStrikeChange() {
            const dataType = document.getElementById('dataType').value;
            const date = getSelectedDate();
            const strike = document.getElementById('strikeSelect').value;
            
            if (!date || !strike) return;
            
            // Get expiries for the selected date and strike
            if (dataType === 'nifty_call' || dataType === 'nifty_put' || 
                dataType === 'banknifty_call' || dataType === 'banknifty_put' ||
                dataType === 'midcpnifty_call' || dataType === 'midcpnifty_put' ||
                dataType === 'sensex_call' || dataType === 'sensex_put') {
                
                // Determine symbol from data type
                let symbol = 'nifty';
                if (dataType.startsWith('banknifty_')) {
                    symbol = 'banknifty';
                } else if (dataType.startsWith('midcpnifty_')) {
                    symbol = 'midcpnifty';
                } else if (dataType.startsWith('sensex_')) {
                    symbol = 'sensex';
                }
                
                fetch(`/get_expiries?date=${date}&strike=${strike}&data_type=${dataType}&symbol=${symbol}`)
                    .then(response => response.json())
                    .then(data => {
                        const expirySelect = document.getElementById('expirySelect');
                        expirySelect.innerHTML = '<option value="">Choose expiry date...</option>';
                        
                        if (data.expiries && data.expiries.length > 0) {
                            data.expiries.forEach(expiry => {
                                const option = document.createElement('option');
                                option.value = expiry;
                                option.textContent = expiry;
                                expirySelect.appendChild(option);
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching expiries:', error);
                    });
            }
        }

        function generateChart() {
            const dataType = document.getElementById('dataType').value;
            const date = getSelectedDate();
            const chartType = document.getElementById('chartType').value;
            const timeframe = document.getElementById('timeframe').value;
            
            // Debug: Log the selected timeframe
            console.log('Selected timeframe:', timeframe);
            console.log('Timeframe type:', typeof timeframe);
            const strike = document.getElementById('strikeSelect').value;
            const expiry = document.getElementById('expirySelect').value;

            if (!date) {
                const year = document.getElementById('yearSelect').value;
                const month = document.getElementById('monthSelect').value;
                const day = document.getElementById('daySelect').value;
                
                let missingFields = [];
                if (!year) missingFields.push('Year');
                if (!month) missingFields.push('Month');
                if (!day) missingFields.push('Day');
                
                showError(`Please select ${missingFields.join(', ')} from the dropdown${missingFields.length > 1 ? 's' : ''} to generate the chart.`);
                return;
            }
            
            // Check if selected date is a weekend
            const selectedDateObj = new Date(date);
            if (isWeekend(selectedDateObj)) {
                const nextTradingDay = findNextTradingDay(selectedDateObj);
                const nextTradingDate = nextTradingDay.toISOString().split('T')[0];
                const nextTradingStr = nextTradingDay.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                
                showError(`Weekend selected: ${date} (${selectedDateObj.toLocaleDateString('en-US', { weekday: 'long' })})<br>
                          No trading data available on weekends.<br>
                          <strong>Next trading day:</strong> ${nextTradingStr}<br>
                          <button onclick="navigateToDate('${nextTradingDate}')" style="background: #00ccff; color: white; border: none; padding: 5px 10px; border-radius: 5px; margin-top: 5px; cursor: pointer;">
                              üìÖ Go to ${nextTradingDate}
                          </button>`);
                return;
            }

            // Validate timeframe
            if (!timeframe || timeframe < 1 || timeframe > 60) {
                showError('Please select a valid timeframe between 1 and 60 minutes');
                return;
            }

            // For options, validate strike and expiry
            if (dataType === 'nifty_call' || dataType === 'nifty_put' || 
                dataType === 'banknifty_call' || dataType === 'banknifty_put' ||
                dataType === 'midcpnifty_call' || dataType === 'midcpnifty_put' ||
                dataType === 'sensex_call' || dataType === 'sensex_put') {
                if (!strike) {
                    showError('Please select a strike price for options');
                    return;
                }
                if (!expiry) {
                    showError('Please select an expiry date for options');
                    return;
                }
            }

            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('chartSection').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('interactiveChartError').style.display = 'none';
            
            // Clear interactive chart button
            const existingBtn = document.getElementById('interactiveChartBtn');
            if (existingBtn) {
                existingBtn.remove();
            }

            // Prepare form data
            const formData = new FormData();
            formData.append('data_type', dataType);
            formData.append('date', date);
            formData.append('chart_type', chartType);
            formData.append('timeframe', timeframe);
            
            // Add symbol parameter
            let symbol = 'nifty';
            if (dataType.startsWith('banknifty_')) {
                symbol = 'banknifty';
            } else if (dataType.startsWith('midcpnifty_')) {
                symbol = 'midcpnifty';
            } else if (dataType.startsWith('sensex_')) {
                symbol = 'sensex';
            }
            formData.append('symbol', symbol);
            
            // Debug: Log timeframe being sent
            console.log('Sending timeframe to backend:', timeframe);
            console.log('Timeframe input element:', document.getElementById('timeframe'));
            console.log('Timeframe input value:', document.getElementById('timeframe').value);
            console.log('Timeframe type:', typeof timeframe);
            
            // Add strike and expiry for options
            if (strike) formData.append('strike', strike);
            if (expiry) formData.append('expiry', expiry);

            // Send request
            fetch('/generate_chart', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('loading').style.display = 'none';
                
                // Debug: Log backend response
                console.log('Chart generated:', data.chart_title, 'Records:', data.record_count);
                
                if (data.success) {
                    displayChart(data);
                } else {
                    showError(data.error || 'Failed to generate chart');
                }
            })
            .catch(error => {
                document.getElementById('loading').style.display = 'none';
                showError('Network error: ' + error.message);
            });
        }

        function displayChart(data) {
            // Store chart data globally for interactive chart switching
            window.lastChartData = data;
            
            // Display chart image
            const chartImage = document.getElementById('chartImage');
            chartImage.src = 'data:image/png;base64,' + data.chart_base64;
            
            // Update chart title
            document.getElementById('chartTitle').textContent = data.chart_title;
            
            // Update chart info
            const chartInfo = document.getElementById('chartInfo');
            chartInfo.innerHTML = '';
            
            // Add record count
            if (data.record_count) {
                addInfoItem(chartInfo, 'Records', data.record_count);
            }
            
            // Add time frame info
            if (data.time_frame) {
                addInfoItem(chartInfo, 'Market Open', data.time_frame.market_open);
                addInfoItem(chartInfo, 'Market Close', data.time_frame.market_close);
                addInfoItem(chartInfo, 'Duration', data.time_frame.trading_duration);
                addInfoItem(chartInfo, 'Intervals', data.time_frame.data_intervals);
            }
            
            // Add data source with user-friendly names
            if (data.data_source) {
                const displayNames = {
                    'nifty_cash': 'SPOT',
                    'nifty_future': 'FUTURE',
                    'nifty_call': 'CALL',
                    'nifty_put': 'PUT',
                    'banknifty_cash': 'SPOT',
                    'banknifty_future': 'FUTURE',
                    'banknifty_call': 'CALL',
                    'banknifty_put': 'PUT',
                    'midcpnifty_cash': 'SPOT',
                    'midcpnifty_future': 'FUTURE',
                    'midcpnifty_call': 'CALL',
                    'midcpnifty_put': 'PUT',
                    'sensex_cash': 'SPOT',
                    'sensex_future': 'FUTURE',
                    'sensex_call': 'CALL',
                    'sensex_put': 'PUT'
                };
                const dataSourceDisplay = displayNames[data.data_source] || data.data_source.replace('_', ' ').toUpperCase();
                addInfoItem(chartInfo, 'Data Source', dataSourceDisplay);
            }
            
            // Add timeframe for candlestick charts
            if (data.timeframe) {
                addInfoItem(chartInfo, 'Timeframe', data.timeframe + ' min');
            }
            
            // Show chart section
            document.getElementById('chartSection').style.display = 'block';
            
            // Show interactive chart option for candlestick charts
            if (data.chart_data && data.chart_data.length > 0) {
                // Add interactive chart button
                const chartContainer = document.querySelector('.chart-container');
                if (!document.getElementById('interactiveChartBtn')) {
                    const interactiveBtn = document.createElement('button');
                    interactiveBtn.id = 'interactiveChartBtn';
                    interactiveBtn.className = 'interactive-btn';
                    interactiveBtn.innerHTML = 'üîÑ Show Interactive Chart';
                    interactiveBtn.onclick = () => {
                        console.log('Interactive chart button clicked!');
                        console.log('Data available:', !!data);
                        console.log('Chart data available:', !!data.chart_data);
                        displayInteractiveChart(data, 'candlestick');
                    };
                    chartContainer.appendChild(interactiveBtn);
                }
            }
        }

        function addInfoItem(container, label, value) {
            const item = document.createElement('div');
            item.className = 'info-item';
            item.innerHTML = `
                <div class="label">${label}</div>
                <div class="value">${value}</div>
            `;
            container.appendChild(item);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        // Function to go back to main page
        function goBack() {
            window.location.href = '/';
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set initial data type indicator with user-friendly names
            const currentDataType = '{{ selected_data_type }}';
            let currentSymbol = 'nifty'; // Default symbol
            const displayNames = {
                'nifty_cash': 'Spot',
                'nifty_future': 'Future',
                'nifty_call': 'Call',
                'nifty_put': 'Put',
                'banknifty_cash': 'Spot',
                'banknifty_future': 'Future',
                'banknifty_call': 'Call',
                'banknifty_put': 'Put',
                'midcpnifty_cash': 'Spot',
                'midcpnifty_future': 'Future',
                'midcpnifty_call': 'Call',
                'midcpnifty_put': 'Put',
                'sensex_cash': 'Spot',
                'sensex_future': 'Future',
                'sensex_call': 'Call',
                'sensex_put': 'Put'
            };
            document.getElementById('currentDataType').textContent = displayNames[currentDataType] || currentDataType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            // Show/hide strike and expiry dropdowns based on initial data type
            const strikeGroup = document.getElementById('strikeGroup');
            const expiryGroup = document.getElementById('expiryGroup');
            
            if (currentDataType === 'nifty_call' || currentDataType === 'nifty_put' || 
                currentDataType === 'banknifty_call' || currentDataType === 'banknifty_put' ||
                currentDataType === 'midcpnifty_call' || currentDataType === 'midcpnifty_put' ||
                currentDataType === 'sensex_call' || currentDataType === 'sensex_put') {
                strikeGroup.style.display = 'flex';
                expiryGroup.style.display = 'flex';
            } else {
                strikeGroup.style.display = 'none';
                expiryGroup.style.display = 'none';
            }
            
            updateTimeframeDisplay();
            
            let symbol = 'nifty';
            if (currentDataType.startsWith('banknifty_')) {
                symbol = 'banknifty';
                currentSymbol = 'banknifty';
            } else if (currentDataType.startsWith('midcpnifty_')) {
                symbol = 'midcpnifty';
                currentSymbol = 'midcpnifty';
            } else if (currentDataType.startsWith('sensex_')) {
                symbol = 'sensex';
                currentSymbol = 'sensex';
            }
            
            // Fetch and populate date selectors
            fetch(`/get_date_range?data_type=${currentDataType}&symbol=${symbol}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Initial date range API response:', data);
                    if (data.date_range) {
                        populateDateSelectors(data.date_range);
                    } else if (data.error) {
                        console.error('API error:', data.error);
                        const dateRangeInfo = document.getElementById('dateRangeInfo');
                        dateRangeInfo.innerHTML = `
                            <strong>Error:</strong> ${data.error}<br>
                            <small style="color: #ff4444;">
                                Please try refreshing the page or contact support.
                            </small>
                        `;
                    } else {
                        console.error('No date range data received');
                        const dateRangeInfo = document.getElementById('dateRangeInfo');
                        dateRangeInfo.innerHTML = `
                            <strong>Error:</strong> No date range data received<br>
                            <small style="color: #ff4444;">
                                Please try refreshing the page or contact support.
                            </small>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error fetching date range:', error);
                    const dateRangeInfo = document.getElementById('dateRangeInfo');
                    dateRangeInfo.innerHTML = `
                        <strong>Error:</strong> Failed to fetch date range<br>
                        <small style="color: #ff4444;">
                            Network error: ${error.message}<br>
                            Please check your connection and try again.
                        </small>
                    `;
                });

            const emaToggle = document.getElementById('toggleEMA20');
            const smaToggle = document.getElementById('toggleSMA');
            const vwapToggle = document.getElementById('toggleVWAP');
            const macdToggle = document.getElementById('toggleMACD');
            const rsiToggle = document.getElementById('toggleRSI');
            const supertrendToggle = document.getElementById('toggleSupertrend');
            if (emaToggle) {
                emaToggle.addEventListener('change', updateIndicatorVisibility);
            }
            if (smaToggle) {
                smaToggle.addEventListener('change', updateIndicatorVisibility);
            }
            if (vwapToggle) {
                vwapToggle.addEventListener('change', updateIndicatorVisibility);
            }
            if (macdToggle) {
                macdToggle.addEventListener('change', updateIndicatorVisibility);
            }
            if (rsiToggle) {
                rsiToggle.addEventListener('change', updateIndicatorVisibility);
            }
            if (supertrendToggle) {
                supertrendToggle.addEventListener('change', updateIndicatorVisibility);
            }
        });
        
        // Interactive Chart Variables
        let currentChart = null;
        let candlestickData = [];
        let ema20Series = null;
        let smaSeriesList = [];
        let vwapSeries = null;
        let macdSeries = null;
        let macdSignalSeries = null;
        let rsiSeries = null;
        let supertrendUpSeries = null;
        let supertrendDownSeries = null;
        let emaValuesCache = [];
        let smaValuesCacheList = [];
        let vwapValuesCache = [];
        let macdDataCache = null;
        let rsiValuesCache = [];
        let supertrendValuesCache = [];
        let supertrendDirectionsCache = [];

        let emaPeriod = 20;
        let emaColor = '#ffcc00';
        let smaConfigs = [
            { period: 20, color: '#ff0000', enabled: true },
            { period: 50, color: '#00ccff', enabled: false },
            { period: 200, color: '#ffffff', enabled: false }
        ];
        let rsiPeriod = 14;
        let rsiColor = '#ffaa00';
        let supertrendPeriod = 10;
        let supertrendMultiplier = 3;
        let supertrendUpColor = '#00ff88';
        let supertrendDownColor = '#ff4444';
        
        // Function to check if library is ready
        function isLibraryReady() {
            const hasLightweightCharts = typeof LightweightCharts !== 'undefined';
            const hasCreateChart = hasLightweightCharts && typeof LightweightCharts.createChart === 'function';
            
            console.log('Library check:', {
                hasLightweightCharts,
                hasCreateChart,
                LightweightCharts: typeof LightweightCharts,
                createChart: hasLightweightCharts ? typeof LightweightCharts.createChart : 'N/A'
            });
            
            return hasLightweightCharts && hasCreateChart;
        }
        
        // Function to wait for library to be ready
        function waitForLibrary(maxWaitTime = 10000) {
            return new Promise((resolve, reject) => {
                if (isLibraryReady()) {
                    resolve();
                    return;
                }
                
                const startTime = Date.now();
                const checkInterval = setInterval(() => {
                    if (isLibraryReady()) {
                        clearInterval(checkInterval);
                        resolve();
                    } else if (Date.now() - startTime > maxWaitTime) {
                        clearInterval(checkInterval);
                        reject(new Error('Library failed to load within timeout period'));
                    }
                }, 100);
            });
        }
        
        // Function to display interactive chart
        function displayInteractiveChart(data, chartType) {
            try {
                console.log('=== INTERACTIVE CHART DEBUG ===');
                console.log('Starting interactive chart display with data:', data);
                console.log('Chart type:', chartType);
                console.log('Data structure:', {
                    hasChartData: !!data.chart_data,
                    chartDataLength: data.chart_data ? data.chart_data.length : 'N/A',
                    chartDataSample: data.chart_data ? data.chart_data.slice(0, 2) : 'N/A'
                });
                
                // Check if we have chart data
                if (!data || !data.chart_data || data.chart_data.length === 0) {
                    throw new Error('No chart data available');
                }
                
                console.log('Chart data validation passed');
                
                // Wait for library to be ready
                console.log('Waiting for library to be ready...');
                waitForLibrary().then(() => {
                    console.log('Library is ready, proceeding with chart creation...');
                    
                    document.getElementById('chartImage').style.display = 'none';
                    document.getElementById('interactiveChartContainer').style.display = 'block';
                    const indicatorBar = document.getElementById('indicatorToggleBar');
                    if (indicatorBar) {
                        indicatorBar.style.display = 'flex';
                    }
                    
                    // Change button text
                    const btn = document.getElementById('interactiveChartBtn');
                    if (btn) {
                        btn.innerHTML = 'üñºÔ∏è Show Static Chart';
                        btn.onclick = () => showStaticChart();
                    }
                    
                    // Create interactive candlestick chart
                    if (chartType === 'candlestick') {
                        console.log('Creating candlestick chart...');
                        createInteractiveCandlestickChart(data.chart_data);
                    } else {
                        throw new Error('Interactive chart only available for candlestick charts');
                    }
                }).catch(error => {
                    console.error('Library wait failed:', error);
                    throw new Error('Library not ready: ' + error.message);
                });
                
            } catch (error) {
                console.error('Error creating interactive chart:', error);
                // Fallback to static chart
                document.getElementById('interactiveChartContainer').style.display = 'none';
                document.getElementById('chartImage').style.display = 'block';
                
                // Show detailed error message
                document.getElementById('interactiveChartError').style.display = 'block';
                document.getElementById('interactiveChartError').innerHTML = `
                    <p><strong>Interactive chart failed to load:</strong> ${error.message}</p>
                    <p>This could be due to:</p>
                    <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
                        <li>Internet connection issues</li>
                        <li>Chart library not loading properly</li>
                        <li>Browser compatibility issues</li>
                        <li>Data format issues</li>
                    </ul>
                    <p>The static chart is still available for analysis.</p>
                    <button onclick="retryInteractiveChart()" class="generate-btn" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9rem;">
                        üîÑ Retry Interactive Chart
                    </button>
                `;
            }
        }
        
        // Function to show static chart
        function showStaticChart() {
            document.getElementById('interactiveChartContainer').style.display = 'none';
            document.getElementById('chartImage').style.display = 'block';
            const indicatorBar = document.getElementById('indicatorToggleBar');
            if (indicatorBar) {
                indicatorBar.style.display = 'none';
            }
            
            // Change button text back
            const btn = document.getElementById('interactiveChartBtn');
            if (btn) {
                btn.innerHTML = 'üîÑ Show Interactive Chart';
                btn.onclick = () => {
                    console.log('Interactive chart button clicked (from static view)!');
                    console.log('Last chart data available:', !!window.lastChartData);
                    displayInteractiveChart(window.lastChartData, 'candlestick');
                };
            }
        }
        
        // Function to retry interactive chart
        function retryInteractiveChart() {
            // Hide error message
            document.getElementById('interactiveChartError').style.display = 'none';
            
            // Try to display interactive chart again
            if (window.lastChartData) {
                displayInteractiveChart(window.lastChartData, 'candlestick');
            } else {
                showError('No chart data available for retry. Please generate a chart first.');
            }
        }
        
        // Function to create interactive candlestick chart
        function createInteractiveCandlestickChart(chartData) {
            try {
                console.log('=== INTERACTIVE CHART CREATION START ===');
                console.log('Creating interactive candlestick chart with data:', chartData);
                console.log('Chart data length:', chartData.length);
                console.log('Chart data type:', typeof chartData);
                console.log('Is array:', Array.isArray(chartData));
                console.log('First few data points:', chartData.slice(0, 3));
                
                if (!chartData || chartData.length === 0) {
                    throw new Error('No chart data provided to createInteractiveCandlestickChart');
                }
                
                // Check if library is available
                if (typeof LightweightCharts === 'undefined') {
                    throw new Error('LightweightCharts library not available');
                }
                
                // Validate chart data
                if (!chartData || !Array.isArray(chartData) || chartData.length === 0) {
                    throw new Error('Invalid chart data: ' + JSON.stringify(chartData));
                }
                
                // Check if required fields exist in first data point
                const firstPoint = chartData[0];
                if (!firstPoint.time || firstPoint.open === undefined || firstPoint.high === undefined || 
                    firstPoint.low === undefined || firstPoint.close === undefined) {
                    throw new Error('Invalid data structure. Required fields: time, open, high, low, close');
                }
                
                // Debug: Show time data analysis
                console.log('=== TIME DATA ANALYSIS ===');
                console.log('First 5 time values:', chartData.slice(0, 5).map(c => c.time));
                console.log('Time data types:', chartData.slice(0, 5).map(c => typeof c.time));
                console.log('Sample time data:', chartData.slice(0, 5).map(c => ({ time: c.time, open: c.open, close: c.close })));
                console.log('========================');
                
                if (currentChart) {
                    try {
                        currentChart.remove();
                    } catch (e) {
                        console.warn('Error removing existing chart:', e);
                    }
                    currentChart = null;
                }

                if (ema20Series && currentChart) {
                    try {
                        currentChart.removeSeries(ema20Series);
                    } catch (e) {}
                    ema20Series = null;
                }
                if (smaSeriesList && currentChart) {
                    for (let i = 0; i < smaSeriesList.length; i++) {
                        const series = smaSeriesList[i];
                        if (series) {
                            try {
                                currentChart.removeSeries(series);
                            } catch (e) {}
                        }
                    }
                    smaSeriesList = [];
                }
                if (vwapSeries && currentChart) {
                    try {
                        currentChart.removeSeries(vwapSeries);
                    } catch (e) {}
                    vwapSeries = null;
                }
                if (macdSeries && currentChart) {
                    try {
                        currentChart.removeSeries(macdSeries);
                    } catch (e) {}
                    macdSeries = null;
                }
                if (macdSignalSeries && currentChart) {
                    try {
                        currentChart.removeSeries(macdSignalSeries);
                    } catch (e) {}
                    macdSignalSeries = null;
                }
                if (rsiSeries && currentChart) {
                    try {
                        currentChart.removeSeries(rsiSeries);
                    } catch (e) {}
                    rsiSeries = null;
                }
                if (supertrendUpSeries && currentChart) {
                    try {
                        currentChart.removeSeries(supertrendUpSeries);
                    } catch (e) {}
                    supertrendUpSeries = null;
                }
                if (supertrendDownSeries && currentChart) {
                    try {
                        currentChart.removeSeries(supertrendDownSeries);
                    } catch (e) {}
                    supertrendDownSeries = null;
                }

                const chartContainer = document.getElementById('candlestickChart');
                const tooltipContainer = document.getElementById('interactiveChartContainer');
                if (!chartContainer || !tooltipContainer) {
                    throw new Error('Chart container not found');
                }
                
                console.log('Chart container dimensions:', chartContainer.clientWidth, 'x', chartContainer.clientHeight);
                
                if (chartContainer.clientWidth === 0 || chartContainer.clientHeight === 0) {
                    chartContainer.style.width = '100%';
                    chartContainer.style.height = '500px';
                }
                
                console.log('Creating chart with LightweightCharts...');
                console.log('LightweightCharts object:', LightweightCharts);
                console.log('createChart method:', LightweightCharts.createChart);
                
                if (typeof LightweightCharts.createChart !== 'function') {
                    throw new Error('LightweightCharts.createChart is not a function. Library may not be loaded correctly.');
                }
                
                const chart = LightweightCharts.createChart(chartContainer, {
                    width: Math.max(chartContainer.clientWidth, 800),
                    height: 500,
                    layout: {
                        background: { color: '#1a1a1a' },
                        textColor: '#cccccc',
                    },
                    grid: {
                        vertLines: { color: '#444444', alpha: 0.1 },
                        horzLines: { color: '#444444', alpha: 0.1 },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                        vertLine: {
                            color: '#00aaff',
                            width: 1,
                            style: 3,
                            labelBackgroundColor: '#00aaff',
                            labelVisible: false,
                        },
                        horzLine: {
                            color: '#00aaff',
                            width: 1,
                            style: 3,
                            labelBackgroundColor: '#00aaff',
                            labelVisible: false,
                        },
                    },
                    rightPriceScale: {
                        borderColor: '#444444',
                        textColor: '#cccccc',
                    },
                    timeScale: {
                        borderColor: '#444444',
                        textColor: '#cccccc',
                        timeVisible: true,
                        secondsVisible: false,
                        rightOffset: 12,
                        barSpacing: 3,
                        minBarSpacing: 1,
                        borderVisible: true,
                        fixLeftEdge: true,
                        fixRightEdge: true,
                        tickMarkFormatter: (time) => {
                            const date = new Date(time * 1000);
                            const hours = date.getHours();
                            const minutes = date.getMinutes();
                            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                        },
                        crosshairLabelVisible: true,
                    },
                    leftPriceScale: {
                        visible: false,
                    },
                    watermark: {
                        visible: false,
                    },
                });
                
                if (!chart) {
                    throw new Error('Chart creation failed - chart object is null or undefined');
                }
                
                console.log('Chart object created:', chart);
                console.log('Chart methods available:', Object.getOwnPropertyNames(chart));

                if (typeof chart.addCandlestickSeries !== 'function') {
                    throw new Error('chart.addCandlestickSeries is not a function. Chart object may be invalid.');
                }
                
                console.log('Creating candlestick series...');
                const candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#00ff88',
                    downColor: '#ff4444',
                    borderDownColor: '#ff4444',
                    borderUpColor: '#00ff88',
                    wickDownColor: '#ff4444',
                    wickUpColor: '#00ff88',
                    borderVisible: false,
                    wickThickness: 1,
                });
                
                if (!candlestickSeries) {
                    throw new Error('Failed to create candlestick series');
                }

                console.log('Candlestick series created successfully');

                console.log('Preparing chart data...');
                console.log('Sample time data:', chartData.slice(0, 3).map(c => c.time));
                
                candlestickData = chartData.map((candle, index) => {
                    try {
                        let timeString = candle.time;
                        let hours, minutes, seconds;
                        
                        // Handle different time formats
                        if (timeString.includes(':')) {
                            const timeParts = timeString.split(':');
                            hours = parseInt(timeParts[0]);
                            minutes = parseInt(timeParts[1]);
                            seconds = parseInt(timeParts[2]) || 0;
                        } else if (timeString.length === 6) {
                            hours = parseInt(timeString.substring(0, 2));
                            minutes = parseInt(timeString.substring(2, 4));
                            seconds = parseInt(timeString.substring(4, 6));
                        } else if (!isNaN(parseInt(timeString)) && parseInt(timeString) < 86400) {
                            const totalSeconds = parseInt(timeString);
                            hours = Math.floor(totalSeconds / 3600);
                            minutes = Math.floor((totalSeconds % 3600) / 60);
                            seconds = totalSeconds % 60;
                        } else {
                            throw new Error(`Unsupported time format: ${timeString}`);
                        }
                        
                        // Validate time components
                        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
                            throw new Error(`Invalid time components: hours=${hours}, minutes=${minutes}, seconds=${seconds}`);
                        }
                        
                        // Get the selected date from the new date selector
                        const selectedDate = getSelectedDate();
                        
                        if (!selectedDate) {
                            const year = document.getElementById('yearSelect').value;
                            const month = document.getElementById('monthSelect').value;
                            const day = document.getElementById('daySelect').value;
                            
                            console.error('Chart generation failed: No date selected');
                            console.log('Current dropdown values:', { year, month, day });
                            
                            let missingFields = [];
                            if (!year) missingFields.push('Year');
                            if (!month) missingFields.push('Month');
                            if (!day) missingFields.push('Day');
                            
                            throw new Error(`Please select ${missingFields.join(', ')} from the dropdown${missingFields.length > 1 ? 's' : ''} above to generate the chart.`);
                        }
                        
                        console.log('Successfully got selected date for chart:', selectedDate);
                        
                        // Create a timestamp for the selected date with the given time
                        const formattedTimeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        const selectedDateTime = new Date(selectedDate + 'T' + formattedTimeString);
                        
                        if (isNaN(selectedDateTime.getTime())) {
                            throw new Error('Invalid date/time format');
                        }
                        
                        const timestamp = Math.floor(selectedDateTime.getTime() / 1000);
                        
                        return {
                            time: timestamp,
                            open: parseFloat(candle.open),
                            high: parseFloat(candle.high),
                            low: parseFloat(candle.low),
                            close: parseFloat(candle.close)
                        };
                    } catch (error) {
                        console.error(`Error processing data point ${index}:`, error, candle);
                        throw error;
                    }
                });

                console.log('Processed chart data:', candlestickData.slice(0, 3));
                
                candlestickSeries.setData(candlestickData);
                console.log('Chart data set successfully');

                emaValuesCache = calculateEMA(candlestickData, emaPeriod);
                smaValuesCacheList = [];
                for (let i = 0; i < smaConfigs.length; i++) {
                    smaValuesCacheList.push(calculateSMA(candlestickData, smaConfigs[i].period));
                }
                vwapValuesCache = calculateVWAP(candlestickData);
                macdDataCache = calculateMACD(candlestickData, 12, 26, 9);
                rsiValuesCache = calculateRSI(candlestickData, rsiPeriod);

                const supertrendResult = calculateSupertrend(candlestickData, supertrendPeriod, supertrendMultiplier);
                supertrendValuesCache = supertrendResult.values;
                supertrendDirectionsCache = supertrendResult.directions;

                currentChart = chart;
                console.log('Chart reference stored:', currentChart);

                updateIndicatorVisibility();

                // Handle window resize
                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0 || entries[0].target !== chartContainer) { return; }
                    const newRect = entries[0].contentRect;
                    if (currentChart && !currentChart._disposed) {
                        try {
                            currentChart.applyOptions({ height: newRect.height, width: newRect.width });
                        } catch (e) {
                            console.warn('Resize error:', e);
                        }
                    }
                });

                resizeObserver.observe(chartContainer);

                // Add tooltip for OHLC values
                let lastValidDataTime = 0;
                
                chart.subscribeCrosshairMove(param => {
                    console.log('=== CROSSHAIR MOVE DEBUG ===');
                    console.log('Param received:', param);
                    console.log('Current chart status:', {
                        hasCurrentChart: !!currentChart,
                        isDisposed: currentChart ? currentChart._disposed : 'N/A'
                    });
                    
                    if (!currentChart || currentChart._disposed) {
                        console.log('Chart is disposed or not available, skipping tooltip');
                        return;
                    }
                    
                    const tooltip = document.getElementById('ohlcTooltip');
                    console.log('Tooltip element found:', tooltip);
                    
                    if (!tooltip) {
                        console.error('OHLC tooltip element not found!');
                        return;
                    }
                    
                    // Check if we have ANY useful data
                    const hasValidPoint = param.point && typeof param.point.x === 'number' && typeof param.point.y === 'number';
                    const hasValidTime = param.time !== undefined;
                    const hasValidData = param.seriesData && param.seriesData.size > 0;
                    
                    console.log('Validation check:', {
                        hasValidPoint,
                        hasValidTime,
                        hasValidData,
                        point: param.point,
                        time: param.time
                    });
                    
                    // If we have ANY valid data, show and update the tooltip
                    if (hasValidPoint || hasValidTime || hasValidData) {
                        console.log('Valid data detected, processing tooltip');
                        
                        // Update tooltip content if we have time and series data
                        if (hasValidTime && hasValidData) {
                            const data = param.seriesData.get(candlestickSeries);
                            console.log('Series data:', data);
                            
                            if (data) {
                                const timestamp = param.time;
                                const candleIndex = candlestickData.findIndex(candle => candle.time === timestamp);
                                console.log('Candle index found:', candleIndex);
                                
                                if (candleIndex >= 0 && candleIndex < chartData.length) {
                                    const candle = chartData[candleIndex];
                                    console.log('Candle data:', candle);
                                    
                                    const date = new Date(timestamp * 1000);
                                    const hours = date.getHours();
                                    const minutes = date.getMinutes();
                                    const seconds = date.getSeconds();
                                    
                                    const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                                    
                                    // Update tooltip content
                                    const timeElement = document.getElementById('tooltipTime');
                                    const openElement = document.getElementById('tooltipOpen');
                                    const highElement = document.getElementById('tooltipHigh');
                                    const lowElement = document.getElementById('tooltipLow');
                                    const closeElement = document.getElementById('tooltipClose');
                                    
                                    if (timeElement) timeElement.textContent = formattedTime;
                                    if (openElement) openElement.textContent = candle.open.toFixed(2);
                                    if (highElement) highElement.textContent = candle.high.toFixed(2);
                                    if (lowElement) lowElement.textContent = candle.low.toFixed(2);
                                    if (closeElement) closeElement.textContent = candle.close.toFixed(2);
                                    
                                    console.log('Tooltip content updated');
                                    
                                    // Remember we had valid data
                                    lastValidDataTime = Date.now();
                                }
                            }
                        }
                        
                        // Always show tooltip when we have any valid data
                        tooltip.style.display = 'block';
                        console.log('Tooltip display set to block');
                        
                        // Position tooltip if we have point coordinates
                        if (hasValidPoint) {
                            const rect = chartContainer.getBoundingClientRect();
                            const tooltipWidth = 200; // Approximate tooltip width
                            const tooltipHeight = 120; // Approximate tooltip height
                            
                            console.log('Positioning info:', {
                                rect: rect,
                                tooltipWidth: tooltipWidth,
                                tooltipHeight: tooltipHeight,
                                paramPoint: param.point
                            });
                            
                            // FIXED POSITIONING: Use chart container coordinates, not page coordinates
                            // param.point.x and param.point.y are relative to the chart container
                            let leftPos = param.point.x + 80; // Add 80px offset to the right for much better distance
                            let topPos = param.point.y - 200;  // Add 200px offset above cursor for much better visibility
                            
                            // Adjust for tooltip dimensions to keep it on screen
                            if (leftPos + tooltipWidth > chartContainer.clientWidth) {
                                // If tooltip would go off right edge, position it to the left of cursor
                                leftPos = param.point.x - tooltipWidth - 80; // Offset to the left for much better distance
                            }
                            
                            if (topPos < 0) {
                                // If tooltip would go off top edge, position it below cursor
                                topPos = param.point.y + 80; // Offset below cursor for much better distance
                            }
                            
                            // Ensure tooltip doesn't go off left or right edges
                            if (leftPos < 0) leftPos = 10; // Keep minimum offset
                            if (leftPos + tooltipWidth > chartContainer.clientWidth) leftPos = chartContainer.clientWidth - tooltipWidth - 10; // Keep from right edge
                            
                            // Add debugging
                            console.log('Tooltip positioning:', {
                                cursorX: param.point.x,
                                cursorY: param.point.y,
                                leftPos: leftPos,
                                topPos: topPos,
                                tooltipWidth: tooltipWidth,
                                tooltipHeight: tooltipHeight,
                                chartWidth: chartContainer.clientWidth,
                                chartHeight: chartContainer.clientHeight
                            });
                            
                            // Set position relative to tooltip container (interactiveChartContainer)
                            tooltip.style.left = leftPos + 'px';
                            tooltip.style.top = topPos + 'px';
                            
                            console.log('Tooltip positioned at:', { left: leftPos, top: topPos });
                        }
                    } else {
                        // Only hide if we have NO data AND we're outside the chart area
                        console.log('No valid data detected, checking if we should hide tooltip');
                        
                        // Check if we're completely outside the chart area
                        const rect = chartContainer.getBoundingClientRect();
                        const isOutsideChart = !param.point || 
                                             param.point.x < 0 || 
                                             param.point.x > rect.width || 
                                             param.point.y < 0 || 
                                             param.point.y > rect.height;
                        
                        console.log('Outside chart check:', {
                            hasPoint: !!param.point,
                            pointX: param.point ? param.point.x : 'N/A',
                            pointY: param.point ? param.point.y : 'N/A',
                            chartWidth: rect.width,
                            chartHeight: rect.height,
                            isOutsideChart: isOutsideChart
                        });
                        
                        // Hide tooltip immediately when no valid data (not just when outside chart)
                        if (!hasValidTime && !hasValidData) {
                            console.log('No valid time or series data, hiding tooltip immediately');
                            tooltip.style.display = 'none';
                        } else if (isOutsideChart && (Date.now() - lastValidDataTime) > 500) {
                            console.log('Outside chart area and no recent valid data, hiding tooltip');
                            tooltip.style.display = 'none';
                        } else {
                            console.log('Keeping tooltip visible (inside chart or recent valid data)');
                        }
                    }
                });
                
                console.log('Interactive chart created successfully!');
                
            } catch (error) {
                console.error('Error in createInteractiveCandlestickChart:', error);
                throw error;
            }
        }

        function updateIndicatorVisibility() {
            if (!currentChart || !candlestickData || candlestickData.length === 0) {
                return;
            }
            const showEMA20 = document.getElementById('toggleEMA20') ? document.getElementById('toggleEMA20').checked : false;
            const showSMA = document.getElementById('toggleSMA') ? document.getElementById('toggleSMA').checked : false;
            const showVWAP = document.getElementById('toggleVWAP') ? document.getElementById('toggleVWAP').checked : false;
            const showMACD = document.getElementById('toggleMACD') ? document.getElementById('toggleMACD').checked : false;
            const showRSI = document.getElementById('toggleRSI') ? document.getElementById('toggleRSI').checked : false;
            const showSupertrend = document.getElementById('toggleSupertrend') ? document.getElementById('toggleSupertrend').checked : false;

            if (!showEMA20 && ema20Series && currentChart) {
                try {
                    currentChart.removeSeries(ema20Series);
                } catch (e) {}
                ema20Series = null;
            }
            if (!showSMA && smaSeriesList && currentChart) {
                for (let i = 0; i < smaSeriesList.length; i++) {
                    const series = smaSeriesList[i];
                    if (series) {
                        try {
                            currentChart.removeSeries(series);
                        } catch (e) {}
                    }
                }
                smaSeriesList = [];
            }
            if (!showVWAP && vwapSeries && currentChart) {
                try {
                    currentChart.removeSeries(vwapSeries);
                } catch (e) {}
                vwapSeries = null;
            }
            if (!showMACD && macdSeries && currentChart) {
                try {
                    currentChart.removeSeries(macdSeries);
                } catch (e) {}
                macdSeries = null;
            }
            if (!showMACD && macdSignalSeries && currentChart) {
                try {
                    currentChart.removeSeries(macdSignalSeries);
                } catch (e) {}
                macdSignalSeries = null;
            }
            if (!showRSI && rsiSeries && currentChart) {
                try {
                    currentChart.removeSeries(rsiSeries);
                } catch (e) {}
                rsiSeries = null;
            }
            if (!showSupertrend && supertrendUpSeries && currentChart) {
                try {
                    currentChart.removeSeries(supertrendUpSeries);
                } catch (e) {}
                supertrendUpSeries = null;
            }
            if (!showSupertrend && supertrendDownSeries && currentChart) {
                try {
                    currentChart.removeSeries(supertrendDownSeries);
                } catch (e) {}
                supertrendDownSeries = null;
            }

            if (showEMA20 && emaValuesCache && emaValuesCache.length === candlestickData.length) {
                const data = [];
                for (let i = 0; i < candlestickData.length; i++) {
                    const value = emaValuesCache[i];
                    if (!isNaN(value)) {
                        data.push({ time: candlestickData[i].time, value: value });
                    }
                }
                if (data.length > 0) {
                    if (!ema20Series) {
                        ema20Series = currentChart.addLineSeries({
                            color: emaColor,
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    ema20Series.setData(data);
                }
            }

            if (showSMA && smaValuesCacheList && smaValuesCacheList.length === smaConfigs.length) {
                if (!smaSeriesList || smaSeriesList.length !== smaConfigs.length) {
                    smaSeriesList = new Array(smaConfigs.length).fill(null);
                }
                for (let i = 0; i < smaConfigs.length; i++) {
                    const config = smaConfigs[i];
                    const values = smaValuesCacheList[i];
                    if (!config || !config.enabled || !values || values.length !== candlestickData.length) {
                        if (smaSeriesList[i] && currentChart) {
                            try {
                                currentChart.removeSeries(smaSeriesList[i]);
                            } catch (e) {}
                            smaSeriesList[i] = null;
                        }
                        continue;
                    }
                    const data = [];
                    for (let j = 0; j < candlestickData.length; j++) {
                        const value = values[j];
                        if (!isNaN(value)) {
                            data.push({ time: candlestickData[j].time, value: value });
                        }
                    }
                    if (data.length === 0) {
                        if (smaSeriesList[i] && currentChart) {
                            try {
                                currentChart.removeSeries(smaSeriesList[i]);
                            } catch (e) {}
                            smaSeriesList[i] = null;
                        }
                        continue;
                    }
                    if (!smaSeriesList[i]) {
                        smaSeriesList[i] = currentChart.addLineSeries({
                            color: config.color,
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    } else {
                        smaSeriesList[i].applyOptions({
                            color: config.color
                        });
                    }
                    smaSeriesList[i].setData(data);
                }
            }

            if (showVWAP && vwapValuesCache && vwapValuesCache.length === candlestickData.length) {
                const data = [];
                for (let i = 0; i < candlestickData.length; i++) {
                    const value = vwapValuesCache[i];
                    if (!isNaN(value)) {
                        data.push({ time: candlestickData[i].time, value: value });
                    }
                }
                if (data.length > 0) {
                    if (!vwapSeries) {
                        vwapSeries = currentChart.addLineSeries({
                            color: '#00ccff',
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    vwapSeries.setData(data);
                }
            }

            if (showMACD && macdDataCache && macdDataCache.macdLine && macdDataCache.macdLine.length > 0) {
                const macdSeriesData = [];
                const signalSeriesData = [];
                const length = Math.min(candlestickData.length, macdDataCache.macdLine.length, macdDataCache.signalLine.length);
                for (let i = 0; i < length; i++) {
                    const macdValue = macdDataCache.macdLine[i];
                    const signalValue = macdDataCache.signalLine[i];
                    if (!isNaN(macdValue) && !isNaN(signalValue)) {
                        const time = candlestickData[i].time;
                        macdSeriesData.push({ time: time, value: macdValue });
                        signalSeriesData.push({ time: time, value: signalValue });
                    }
                }
                if (macdSeriesData.length > 0) {
                    if (!macdSeries) {
                        macdSeries = currentChart.addLineSeries({
                            color: '#ff4444',
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    if (!macdSignalSeries) {
                        macdSignalSeries = currentChart.addLineSeries({
                            color: '#00ff88',
                            lineWidth: 1,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    macdSeries.setData(macdSeriesData);
                    macdSignalSeries.setData(signalSeriesData);
                }
            }

            if (showRSI && rsiValuesCache && rsiValuesCache.length > 0) {
                const rsiSeriesData = [];
                for (let i = 0; i < rsiValuesCache.length; i++) {
                    const index = i + rsiPeriod;
                    if (index < candlestickData.length) {
                        const value = rsiValuesCache[i];
                        if (!isNaN(value)) {
                            rsiSeriesData.push({
                                time: candlestickData[index].time,
                                value: value
                            });
                        }
                    }
                }
                if (rsiSeriesData.length > 0) {
                    if (!rsiSeries) {
                        rsiSeries = currentChart.addLineSeries({
                            color: rsiColor,
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    rsiSeries.setData(rsiSeriesData);
                }
            }

            if (showSupertrend && supertrendValuesCache && supertrendValuesCache.length === candlestickData.length && supertrendDirectionsCache && supertrendDirectionsCache.length === candlestickData.length) {
                const upData = [];
                const downData = [];
                for (let i = 0; i < candlestickData.length; i++) {
                    const value = supertrendValuesCache[i];
                    const dir = supertrendDirectionsCache[i];
                    if (isNaN(value) || dir === 0) {
                        continue;
                    }
                    const point = { time: candlestickData[i].time, value: value };
                    if (dir > 0) {
                        upData.push(point);
                    } else {
                        downData.push(point);
                    }
                }
                if (upData.length > 0) {
                    if (!supertrendUpSeries) {
                        supertrendUpSeries = currentChart.addLineSeries({
                            color: supertrendUpColor,
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    supertrendUpSeries.setData(upData);
                }
                if (downData.length > 0) {
                    if (!supertrendDownSeries) {
                        supertrendDownSeries = currentChart.addLineSeries({
                            color: supertrendDownColor,
                            lineWidth: 2,
                            priceLineVisible: false,
                            lastValueVisible: false
                        });
                    }
                    supertrendDownSeries.setData(downData);
                }
            }
        }

        function calculateVWAP(data) {
            if (!data || data.length === 0) {
                return [];
            }
            const values = [];
            let cumulativeTPV = 0;
            let cumulativeVolume = 0;
            for (let i = 0; i < data.length; i++) {
                const candle = data[i];
                const typicalPrice = (candle.high + candle.low + candle.close) / 3;
                const volume = 1;
                cumulativeTPV += typicalPrice * volume;
                cumulativeVolume += volume;
                values.push(cumulativeTPV / cumulativeVolume);
            }
            return values;
        }

        function calculateEMA(data, period) {
            if (!data || data.length === 0 || !period || data.length < period) {
                return [];
            }
            const alpha = 2 / (period + 1);
            const result = [data[0].close];
            for (let i = 1; i < data.length; i++) {
                const value = alpha * data[i].close + (1 - alpha) * result[result.length - 1];
                result.push(value);
            }
            return result;
        }

        function calculateSMA(data, period) {
            if (!data || data.length === 0 || !period || data.length < period) {
                return [];
            }
            const result = new Array(data.length).fill(NaN);
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i].close;
                if (i >= period) {
                    sum -= data[i - period].close;
                }
                if (i >= period - 1) {
                    result[i] = sum / period;
                }
            }
            return result;
        }

        function calculateEMAFromValues(values, period) {
            if (!values || values.length === 0 || !period) {
                return [];
            }
            const ema = [];
            const multiplier = 2 / (period + 1);
            let sum = 0;
            const length = Math.min(period, values.length);
            for (let i = 0; i < length; i++) {
                sum += values[i];
            }
            const initial = sum / length;
            ema.push(initial);
            for (let i = 1; i < values.length; i++) {
                const value = values[i] * multiplier + ema[i - 1] * (1 - multiplier);
                ema.push(value);
            }
            return ema;
        }

        function calculateMACD(data, fastPeriod, slowPeriod, signalPeriod) {
            const result = { macdLine: [], signalLine: [], histogram: [] };
            if (!data || data.length === 0) {
                return result;
            }
            const maxPeriod = Math.max(fastPeriod, slowPeriod, signalPeriod);
            if (data.length < maxPeriod) {
                return result;
            }
            const fastEMA = calculateEMA(data, fastPeriod);
            const slowEMA = calculateEMA(data, slowPeriod);
            if (!fastEMA.length || !slowEMA.length) {
                return result;
            }
            const macdLine = [];
            for (let i = 0; i < data.length; i++) {
                if (fastEMA[i] !== undefined && slowEMA[i] !== undefined && !isNaN(fastEMA[i]) && !isNaN(slowEMA[i])) {
                    macdLine.push(fastEMA[i] - slowEMA[i]);
                } else {
                    macdLine.push(NaN);
                }
            }
            const signalLine = calculateEMAFromValues(macdLine, signalPeriod);
            const histogram = [];
            for (let i = 0; i < data.length; i++) {
                if (macdLine[i] !== undefined && signalLine[i] !== undefined && !isNaN(macdLine[i]) && !isNaN(signalLine[i])) {
                    histogram.push(macdLine[i] - signalLine[i]);
                } else {
                    histogram.push(NaN);
                }
            }
            result.macdLine = macdLine;
            result.signalLine = signalLine;
            result.histogram = histogram;
            return result;
        }

        function calculateATR(data, period) {
            if (!data || data.length === 0 || !period || data.length < period + 1) {
                return [];
            }
            const atr = new Array(data.length).fill(NaN);
            let prevClose = data[0].close;
            let trSum = 0;
            for (let i = 0; i < data.length; i++) {
                const high = data[i].high;
                const low = data[i].low;
                const tr = Math.max(
                    high - low,
                    Math.abs(high - prevClose),
                    Math.abs(low - prevClose)
                );
                prevClose = data[i].close;
                if (i < period) {
                    trSum += tr;
                    if (i === period - 1) {
                        atr[i] = trSum / period;
                    }
                } else {
                    atr[i] = (atr[i - 1] * (period - 1) + tr) / period;
                }
            }
            return atr;
        }

        function calculateSupertrend(data, period, multiplier) {
            const length = data ? data.length : 0;
            if (!data || length === 0 || !period || length < period + 1) {
                return { values: [], directions: [] };
            }
            const atr = calculateATR(data, period);
            const basicUpper = new Array(length).fill(NaN);
            const basicLower = new Array(length).fill(NaN);
            const finalUpper = new Array(length).fill(NaN);
            const finalLower = new Array(length).fill(NaN);
            const supertrend = new Array(length).fill(NaN);
            const directions = new Array(length).fill(0);

            for (let i = 0; i < length; i++) {
                if (isNaN(atr[i])) {
                    continue;
                }
                const hl2 = (data[i].high + data[i].low) / 2;
                basicUpper[i] = hl2 + multiplier * atr[i];
                basicLower[i] = hl2 - multiplier * atr[i];
            }

            for (let i = 0; i < length; i++) {
                if (i === 0 || isNaN(basicUpper[i]) || isNaN(basicLower[i])) {
                    finalUpper[i] = basicUpper[i];
                    finalLower[i] = basicLower[i];
                    continue;
                }
                const prevClose = data[i - 1].close;

                if (!isNaN(finalUpper[i - 1])) {
                    finalUpper[i] = finalUpper[i - 1];
                    if (basicUpper[i] < finalUpper[i - 1] && prevClose > finalUpper[i - 1]) {
                        finalUpper[i] = basicUpper[i];
                    }
                } else {
                    finalUpper[i] = basicUpper[i];
                }

                if (!isNaN(finalLower[i - 1])) {
                    finalLower[i] = finalLower[i - 1];
                    if (basicLower[i] > finalLower[i - 1] && prevClose < finalLower[i - 1]) {
                        finalLower[i] = basicLower[i];
                    }
                } else {
                    finalLower[i] = basicLower[i];
                }
            }

            for (let i = 0; i < length; i++) {
                if (i === 0 || isNaN(finalUpper[i]) || isNaN(finalLower[i])) {
                    supertrend[i] = NaN;
                    directions[i] = 0;
                    continue;
                }
                const close = data[i].close;
                if (i === 1 || isNaN(supertrend[i - 1])) {
                    if (close >= finalLower[i]) {
                        supertrend[i] = finalLower[i];
                        directions[i] = 1;
                    } else {
                        supertrend[i] = finalUpper[i];
                        directions[i] = -1;
                    }
                    continue;
                }

                if (supertrend[i - 1] === finalUpper[i - 1]) {
                    if (close <= finalUpper[i]) {
                        supertrend[i] = finalUpper[i];
                        directions[i] = -1;
                    } else {
                        supertrend[i] = finalLower[i];
                        directions[i] = 1;
                    }
                } else {
                    if (close >= finalLower[i]) {
                        supertrend[i] = finalLower[i];
                        directions[i] = 1;
                    } else {
                        supertrend[i] = finalUpper[i];
                        directions[i] = -1;
                    }
                }
            }

            console.log('Supertrend debug sample:', {
                firstValues: supertrend.slice(0, 10),
                firstDirs: directions.slice(0, 10)
            });

            return { values: supertrend, directions: directions };
        }

        function calculateRSI(data, period) {
            if (!data || data.length === 0 || !period || data.length < period + 1) {
                return [];
            }
            const priceChanges = [];
            for (let i = 1; i < data.length; i++) {
                priceChanges.push(data[i].close - data[i - 1].close);
            }
            const gains = priceChanges.map(v => (v > 0 ? v : 0));
            const losses = priceChanges.map(v => (v < 0 ? -v : 0));
            let avgGain = 0;
            let avgLoss = 0;
            for (let i = 0; i < period; i++) {
                avgGain += gains[i];
                avgLoss += losses[i];
            }
            avgGain /= period;
            avgLoss /= period;
            const rsiValues = [];
            if (avgLoss === 0) {
                rsiValues.push(100);
            } else {
                const rs = avgGain / avgLoss;
                const rsi = 100 - 100 / (1 + rs);
                rsiValues.push(rsi);
            }
            for (let i = period; i < priceChanges.length; i++) {
                avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
                avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
                if (avgLoss === 0) {
                    rsiValues.push(100);
                } else {
                    const rs = avgGain / avgLoss;
                    const rsi = 100 - 100 / (1 + rs);
                    rsiValues.push(rsi);
                }
            }
            return rsiValues;
        }

        function navigateToDate(targetDate) {
            const dateParts = targetDate.split('-');
            
            // Update selectors
            const yearSelect = document.getElementById('yearSelect');
            const monthSelect = document.getElementById('monthSelect');
            const daySelect = document.getElementById('daySelect');
            
            // Set year first
            yearSelect.value = dateParts[0];
            delete yearSelect.dataset.lastYear;
            updateDateOptions();
            
            // Set month and day
            monthSelect.value = dateParts[1];
            daySelect.value = dateParts[2];
            
            // Update debug display
            updateDebugDisplay();
            
            // Clear any error messages
            const errorDiv = document.getElementById('errorMessage');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
            
            // Show success message
            showSuccess(`Successfully navigated to ${targetDate}`);
        }

        function showSuccess(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<div style="color: #00ff88; background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); padding: 10px; border-radius: 8px;">‚úÖ ${message}</div>`;
            errorDiv.style.display = 'block';
            
            // Hide after 3 seconds
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 3000);
        }

        function openEMAModal() {
            const modal = document.getElementById('emaSettingsModal');
            if (!modal) return;
            const periodInput = document.getElementById('emaPeriodInput');
            const colorInput = document.getElementById('emaColorInput');
            if (periodInput) periodInput.value = emaPeriod;
            if (colorInput) colorInput.value = emaColor;
            modal.style.display = 'flex';
        }

        function closeEMAModal() {
            const modal = document.getElementById('emaSettingsModal');
            if (modal) modal.style.display = 'none';
        }

        function applyEMAModal() {
            const periodInput = document.getElementById('emaPeriodInput');
            const colorInput = document.getElementById('emaColorInput');
            if (periodInput) {
                const value = parseInt(periodInput.value, 10);
                if (!isNaN(value) && value > 0) {
                    emaPeriod = value;
                }
            }
            if (colorInput && colorInput.value) {
                emaColor = colorInput.value;
            }
            if (candlestickData && candlestickData.length > 0) {
                emaValuesCache = calculateEMA(candlestickData, emaPeriod);
            }
            closeEMAModal();
            updateIndicatorVisibility();
        }

        function openSMAModal() {
            const modal = document.getElementById('smaSettingsModal');
            if (!modal) return;
            const p1 = document.getElementById('sma1PeriodInput');
            const c1 = document.getElementById('sma1ColorInput');
            const e1 = document.getElementById('sma1Enabled');
            const p2 = document.getElementById('sma2PeriodInput');
            const c2 = document.getElementById('sma2ColorInput');
            const e2 = document.getElementById('sma2Enabled');
            const p3 = document.getElementById('sma3PeriodInput');
            const c3 = document.getElementById('sma3ColorInput');
            const e3 = document.getElementById('sma3Enabled');
            if (smaConfigs[0]) {
                if (p1) p1.value = smaConfigs[0].period;
                if (c1) c1.value = smaConfigs[0].color;
                if (e1) e1.checked = smaConfigs[0].enabled;
            }
            if (smaConfigs[1]) {
                if (p2) p2.value = smaConfigs[1].period;
                if (c2) c2.value = smaConfigs[1].color;
                if (e2) e2.checked = smaConfigs[1].enabled;
            }
            if (smaConfigs[2]) {
                if (p3) p3.value = smaConfigs[2].period;
                if (c3) c3.value = smaConfigs[2].color;
                if (e3) e3.checked = smaConfigs[2].enabled;
            }
            modal.style.display = 'flex';
        }

        function closeSMAModal() {
            const modal = document.getElementById('smaSettingsModal');
            if (modal) modal.style.display = 'none';
        }

        function applySMAModal() {
            const p1 = document.getElementById('sma1PeriodInput');
            const c1 = document.getElementById('sma1ColorInput');
            const e1 = document.getElementById('sma1Enabled');
            const p2 = document.getElementById('sma2PeriodInput');
            const c2 = document.getElementById('sma2ColorInput');
            const e2 = document.getElementById('sma2Enabled');
            const p3 = document.getElementById('sma3PeriodInput');
            const c3 = document.getElementById('sma3ColorInput');
            const e3 = document.getElementById('sma3Enabled');

            const inputs = [
                { p: p1, c: c1, e: e1 },
                { p: p2, c: c2, e: e2 },
                { p: p3, c: c3, e: e3 }
            ];

            for (let i = 0; i < smaConfigs.length && i < inputs.length; i++) {
                const cfg = smaConfigs[i];
                const row = inputs[i];
                if (!cfg || !row) continue;
                if (row.p) {
                    const v = parseInt(row.p.value, 10);
                    if (!isNaN(v) && v > 0) {
                        cfg.period = v;
                    }
                }
                if (row.c && row.c.value) {
                    cfg.color = row.c.value;
                }
                if (row.e) {
                    cfg.enabled = row.e.checked;
                }
            }

            if (candlestickData && candlestickData.length > 0) {
                smaValuesCacheList = [];
                for (let i = 0; i < smaConfigs.length; i++) {
                    smaValuesCacheList.push(calculateSMA(candlestickData, smaConfigs[i].period));
                }
            }
            closeSMAModal();
            updateIndicatorVisibility();
        }

        function openRSIModal() {
            const modal = document.getElementById('rsiSettingsModal');
            if (!modal) return;
            const periodInput = document.getElementById('rsiPeriodInput');
            const colorInput = document.getElementById('rsiColorInput');
            if (periodInput) periodInput.value = rsiPeriod;
            if (colorInput) colorInput.value = rsiColor;
            modal.style.display = 'flex';
        }

        function closeRSIModal() {
            const modal = document.getElementById('rsiSettingsModal');
            if (modal) modal.style.display = 'none';
        }

        function applyRSIModal() {
            const periodInput = document.getElementById('rsiPeriodInput');
            const colorInput = document.getElementById('rsiColorInput');
            if (periodInput) {
                const value = parseInt(periodInput.value, 10);
                if (!isNaN(value) && value > 0) {
                    rsiPeriod = value;
                }
            }
            if (colorInput && colorInput.value) {
                rsiColor = colorInput.value;
            }
            if (candlestickData && candlestickData.length > 0) {
                rsiValuesCache = calculateRSI(candlestickData, rsiPeriod);
            }
            closeRSIModal();
            updateIndicatorVisibility();
        }

        function openSupertrendModal() {
            const modal = document.getElementById('supertrendSettingsModal');
            if (!modal) return;
            const periodInput = document.getElementById('supertrendPeriodInput');
            const multiplierInput = document.getElementById('supertrendMultiplierInput');
            const upColorInput = document.getElementById('supertrendUpColorInput');
            const downColorInput = document.getElementById('supertrendDownColorInput');
            if (periodInput) periodInput.value = supertrendPeriod;
            if (multiplierInput) multiplierInput.value = supertrendMultiplier;
            if (upColorInput) upColorInput.value = supertrendUpColor;
            if (downColorInput) downColorInput.value = supertrendDownColor;
            modal.style.display = 'flex';
        }

        function closeSupertrendModal() {
            const modal = document.getElementById('supertrendSettingsModal');
            if (modal) modal.style.display = 'none';
        }

        function applySupertrendModal() {
            const periodInput = document.getElementById('supertrendPeriodInput');
            const multiplierInput = document.getElementById('supertrendMultiplierInput');
            const upColorInput = document.getElementById('supertrendUpColorInput');
            const downColorInput = document.getElementById('supertrendDownColorInput');
            if (periodInput) {
                const value = parseInt(periodInput.value, 10);
                if (!isNaN(value) && value > 0) {
                    supertrendPeriod = value;
                }
            }
            if (multiplierInput) {
                const value = parseFloat(multiplierInput.value);
                if (!isNaN(value) && value > 0) {
                    supertrendMultiplier = value;
                }
            }
            if (upColorInput && upColorInput.value) {
                supertrendUpColor = upColorInput.value;
            }
            if (downColorInput && downColorInput.value) {
                supertrendDownColor = downColorInput.value;
            }
            if (candlestickData && candlestickData.length > 0) {
                const supertrendResult = calculateSupertrend(candlestickData, supertrendPeriod, supertrendMultiplier);
                supertrendValuesCache = supertrendResult.values;
                supertrendDirectionsCache = supertrendResult.directions;
            }
            closeSupertrendModal();
            updateIndicatorVisibility();
        }
    </script>
</body>
</html>
